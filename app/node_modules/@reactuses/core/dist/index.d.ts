import * as react from 'react';
import react__default, { MutableRefObject, useEffect, useLayoutEffect, Dispatch, SetStateAction, DependencyList, EffectCallback, RefObject, CSSProperties } from 'react';
import * as lodash from 'lodash';
import Cookies from 'js-cookie';

declare function usePrevious<T>(state: T): T | undefined;

declare function useLatest<T>(value: T): MutableRefObject<T>;

declare function useFirstMountState(): boolean;

declare const _default$4: typeof useEffect | typeof react.useLayoutEffect;

declare const _default$3: typeof react.useEffect | typeof useLayoutEffect;

interface Serializer<T> {
    read(raw: string): T;
    write(value: T): string;
}
interface UseStorageOptions<T> {
    /**
     * Custom data serialization
     */
    serializer?: Serializer<T>;
    /**
     * On error callback
     *
     * Default log error to `console.error`
     */
    onError?: (error: unknown) => void;
    /**
     * set to storage when nodata in effect, fallback to defaults
     */
    csrData?: T | (() => T);
}

declare function useLocalStorage(key: string, defaults: string, options?: UseStorageOptions<string>): readonly [string | null, Dispatch<SetStateAction<string | null>>];
declare function useLocalStorage(key: string, defaults: number, options?: UseStorageOptions<number>): readonly [number | null, Dispatch<SetStateAction<number | null>>];
declare function useLocalStorage(key: string, defaults: boolean, options?: UseStorageOptions<boolean>): readonly [boolean | null, Dispatch<SetStateAction<boolean | null>>];
declare function useLocalStorage<T>(key: string, defaults: T, options?: UseStorageOptions<T>): readonly [T | null, Dispatch<SetStateAction<T | null>>];
declare function useLocalStorage<T = unknown>(key: string, defaults: null, options?: UseStorageOptions<T>): readonly [T | null, Dispatch<SetStateAction<T | null>>];

declare function useSessionStorage(key: string, defaults: string, options?: UseStorageOptions<string>): readonly [string | null, Dispatch<SetStateAction<string | null>>];
declare function useSessionStorage(key: string, defaults: number, options?: UseStorageOptions<number>): readonly [number | null, Dispatch<SetStateAction<number | null>>];
declare function useSessionStorage(key: string, defaults: boolean, options?: UseStorageOptions<boolean>): readonly [boolean | null, Dispatch<SetStateAction<boolean | null>>];
declare function useSessionStorage<T>(key: string, defaults: T, options?: UseStorageOptions<T>): readonly [T | null, Dispatch<SetStateAction<T | null>>];
declare function useSessionStorage<T = unknown>(key: string, defaults: null, options?: UseStorageOptions<T>): readonly [T | null, Dispatch<SetStateAction<T | null>>];

type Fn = (this: any, ...args: any[]) => any;
type Stoppable = [boolean, Fn, Fn];
type PointerType = "mouse" | "touch" | "pen";
interface Position {
    x: number;
    y: number;
}

/**
 * keep function reference immutable
 */
declare function useEvent<T extends Fn>(fn: T): T;

declare function useToggle(initialValue: boolean): [boolean, (nextValue?: any) => void];

declare function useInterval(callback: () => void, delay?: number | null, options?: {
    immediate?: boolean;
}): void;

interface UseDarkOptions {
    /**
     * CSS Selector for the target element applying to
     *
     * @default 'html'
     */
    selector?: string;
    /**
     * HTML attribute applying the target element
     *
     * @default 'class'
     */
    attribute?: string;
    /**
     * isomorphic default value
     * @default false
     */
    defaultValue?: boolean;
    /**
     * Key to persist the data into localStorage/sessionStorage.
     *
     * @default 'reactuses-color-scheme'
     */
    storageKey?: string;
    /**
     * Storage object, can be localStorage or sessionStorage
     *
     * @default localStorage
     */
    storage?: () => Storage;
    /**
     * name dark  apply to element
     */
    classNameDark: string;
    /**
     * name light  apply to element
     */
    classNameLight: string;
}
declare function useDarkMode(options: UseDarkOptions): readonly [boolean | null, () => void, react.Dispatch<react.SetStateAction<boolean | null>>];

declare function useMediaQuery(query: string, defaultState?: boolean): boolean;

declare function usePreferredDark(defaultState?: boolean): boolean;

declare const useIsomorphicLayoutEffect: typeof useEffect;

declare function useMount(fn: () => void): void;

declare function useUnmount(fn: () => void): void;

interface ThrottleSettings {
    leading?: boolean | undefined;
    trailing?: boolean | undefined;
}
interface DebounceSettings {
    leading?: boolean;
    trailing?: boolean;
    maxWait?: number;
}

declare function useThrottle<T>(value: T, wait?: number, options?: ThrottleSettings): T;

declare function useThrottleFn<T extends (...args: any) => any>(fn: T, wait?: number, options?: ThrottleSettings): {
    run: lodash.DebouncedFunc<(...args_0: Parameters<T>) => ReturnType<T>>;
    cancel: () => void;
    flush: () => ReturnType<T> | undefined;
};

declare function useDebounce<T>(value: T, wait?: number, options?: DebounceSettings): T;

declare function useDebounceFn<T extends (...args: any) => any>(fn: T, wait?: number, options?: DebounceSettings): {
    run: lodash.DebouncedFunc<(...args_0: Parameters<T>) => ReturnType<T>>;
    cancel: () => void;
    flush: () => ReturnType<T> | undefined;
};

declare function useRafState<S>(initialState: S | (() => S)): readonly [S, Dispatch<SetStateAction<S>>];

declare function useUpdate(): () => void;

interface UseTimeoutFnOptions {
    /**
     * Start the timer immediate after calling this function
     *
     * @default false
     */
    immediate?: boolean;
}
/**
 * Wrapper for `setTimeout` with controls.
 *
 * @param cb
 * @param interval
 * @param options
 */
declare function useTimeoutFn(cb: (...args: unknown[]) => any, interval: number, options?: UseTimeoutFnOptions): Stoppable;

declare function useTimeout(ms?: number, options?: UseTimeoutFnOptions): Stoppable;

declare function useMountedState(): () => boolean;

type TargetValue<T> = T | undefined | null;
type TargetType = HTMLElement | Element | Window | Document | EventTarget;
type BasicTarget<T extends TargetType = Element> = (() => TargetValue<T>) | TargetValue<T> | MutableRefObject<TargetValue<T>>;

type Target = BasicTarget<HTMLElement | Element | Window | Document | EventTarget>;
declare function useEventListener<K extends keyof WindowEventMap>(eventName: K, handler: (event: WindowEventMap[K]) => void, element?: Window, options?: boolean | AddEventListenerOptions): void;
declare function useEventListener<K extends keyof DocumentEventMap>(eventName: K, handler: (event: DocumentEventMap[K]) => void, element: Document, options?: boolean | AddEventListenerOptions): void;
declare function useEventListener<K extends keyof HTMLElementEventMap, T extends HTMLElement = HTMLDivElement>(eventName: K, handler: (event: HTMLElementEventMap[K]) => void, element: T, options?: boolean | AddEventListenerOptions): void;
declare function useEventListener<K extends keyof ElementEventMap>(eventName: K, handler: (event: ElementEventMap[K]) => void, element: Element, options?: boolean | AddEventListenerOptions): void;
declare function useEventListener<K = Event>(eventName: string, handler: (event: K) => void, element: EventTarget | null | undefined, options?: boolean | AddEventListenerOptions): void;
declare function useEventListener(eventName: string, handler: (...p: any) => void, element?: Target, options?: boolean | AddEventListenerOptions): void;

declare function useCounter(initialValue?: number | (() => number), max?: number | null, min?: number | null): readonly [number, (newState: number | ((prev: number) => number) | (() => number)) => void, (delta?: number) => void, (delta?: number) => void, () => void];

type RafLoopReturns = readonly [() => void, () => void, () => boolean];
declare function useRafFn(callback: FrameRequestCallback, initiallyActive?: boolean): RafLoopReturns;

interface IListener<T, U = void> {
    (arg1: T, arg2: U): void;
}
interface IDisposable {
    dispose(): void;
}
interface IEvent<T, U = void> {
    (listener: (arg1: T, arg2: U) => any): IDisposable;
}
interface IEventOnce<T, U = void> {
    (listener: (arg1: T, arg2: U) => any): void;
}
interface UseEventEmitterReturn<T, U = void> {
    /**
     * Subscribe to an event. When calling emit, the listeners will execute.
     * @param listener watch listener.
     * @returns a stop function to remove the current callback.
     */
    event: IEvent<T, U>;
    /**
     * fire an event, the corresponding event listeners will execute.
     * @param event data sent.
     */
    fire: (arg1: T, arg2: U) => void;
    /**
     * Remove all corresponding listener.
     */
    dispose: () => void;
}
declare function useEventEmitter<T, U = void>(): readonly [IEvent<T, U>, (arg1: T, arg2: U) => void, () => void];

declare function useFavicon(href: string, baseUrl?: string, rel?: string): void;

declare function useMutationObserver(callback: MutationCallback, target: BasicTarget, options?: MutationObserverInit): () => void;

type DepsEqualFnType<TDeps extends DependencyList> = (prevDeps: TDeps, nextDeps: TDeps) => boolean;
declare function useCustomCompareEffect<TDeps extends DependencyList>(effect: EffectCallback, deps: TDeps, depsEqual: DepsEqualFnType<TDeps>): void;

declare function useDeepCompareEffect(effect: EffectCallback, deps: DependencyList): void;

declare function useTitle(title: string): void;

interface UseScriptTagOptions {
    /**
     * Load the script immediately
     *
     * @default true
     */
    immediate?: boolean;
    /**
     * Add `async` attribute to the script tag
     *
     * @default true
     */
    async?: boolean;
    /**
     * Script type
     *
     * @default 'text/javascript'
     */
    type?: string;
    /**
     * Manual controls the timing of loading and unloading
     *
     * @default false
     */
    manual?: boolean;
    crossOrigin?: "anonymous" | "use-credentials";
    referrerPolicy?: "no-referrer" | "no-referrer-when-downgrade" | "origin" | "origin-when-cross-origin" | "same-origin" | "strict-origin" | "strict-origin-when-cross-origin" | "unsafe-url";
    noModule?: boolean;
    defer?: boolean;
    /**
     * Add custom attribute to the script tag
     *
     */
    attrs?: Record<string, string>;
}
type Status = "idle" | "loading" | "ready" | "error";
declare function useScriptTag(src: string, onLoaded?: (el: HTMLScriptElement) => void, options?: UseScriptTagOptions): readonly [HTMLScriptElement | null, Status, (waitForScriptLoad?: boolean) => Promise<HTMLScriptElement | boolean>, () => void];

type IState = PermissionState | "";
type DescriptorNamePolyfill = "accelerometer" | "accessibility-events" | "ambient-light-sensor" | "background-sync" | "camera" | "clipboard-read" | "clipboard-write" | "gyroscope" | "magnetometer" | "microphone" | "notifications" | "payment-handler" | "persistent-storage" | "push" | "speaker";
type GeneralPermissionDescriptor = PermissionDescriptor | {
    name: DescriptorNamePolyfill;
};
declare function usePermission(permissionDesc: GeneralPermissionDescriptor | GeneralPermissionDescriptor["name"]): IState;

interface UseLongPressOptions {
    isPreventDefault?: boolean;
    delay?: number;
}
declare function useLongPress(callback: (e: TouchEvent | MouseEvent) => void, { isPreventDefault, delay }?: UseLongPressOptions): {
    readonly onMouseDown: (e: any) => void;
    readonly onTouchStart: (e: any) => void;
    readonly onMouseUp: () => void;
    readonly onMouseLeave: () => void;
    readonly onTouchEnd: () => void;
};

declare function useObjectUrl(object: Blob | MediaSource | undefined): string | undefined;

declare function useIdle(ms?: number, initialState?: boolean, events?: (keyof WindowEventMap)[]): boolean;

interface UseMediaDeviceOptions {
    /**
     * Request for permissions immediately if it's not granted,
     * otherwise label and deviceIds could be empty
     *
     * @default false
     */
    requestPermissions?: boolean;
    /**
     * Request for types of media permissions
     *
     * @default { audio: true, video: true }
     */
    constraints?: MediaStreamConstraints;
}
declare function useMediaDevices(options?: UseMediaDeviceOptions): readonly [{
    devices: {
        deviceId: string;
        groupId: string;
        kind: MediaDeviceKind;
        label: string;
    }[];
}, () => Promise<boolean>];

type UseTextDirectionValue = "ltr" | "rtl" | "auto";
interface UseTextDirectionOptions {
    /**
     * CSS Selector for the target element applying to
     *
     * @default 'html'
     */
    selector?: string;
    /**
     * Initial value
     *
     * @default 'ltr'
     */
    initialValue?: UseTextDirectionValue;
}
declare function useTextDirection(options?: UseTextDirectionOptions): readonly [UseTextDirectionValue, (value: UseTextDirectionValue) => void];

interface CursorState {
    screenX: number;
    screenY: number;
    clientX: number;
    clientY: number;
    pageX: number;
    pageY: number;
    elementX: number;
    elementY: number;
    elementH: number;
    elementW: number;
    elementPosX: number;
    elementPosY: number;
}
declare function useMouse(target?: BasicTarget): CursorState;

interface UseFpsOptions {
    /**
     * Calculate the FPS on every x frames.
     * @default 10
     */
    every?: number;
}
declare const _default$2: (options?: UseFpsOptions | undefined) => number;

declare function useGeolocation(options?: Partial<PositionOptions>): {
    readonly coordinates: GeolocationCoordinates;
    readonly locatedAt: number | null;
    readonly error: GeolocationPositionError | null;
};

interface UseFullScreenOptions {
    onExit?: () => void;
    onEnter?: () => void;
}
declare function useFullscreen(target: BasicTarget, options?: UseFullScreenOptions): readonly [boolean, {
    readonly enterFullscreen: () => void;
    readonly exitFullscreen: () => void;
    readonly toggleFullscreen: () => void;
    readonly isEnabled: boolean;
}];

interface INetworkInformation extends EventTarget {
    readonly downlink: number;
    readonly downlinkMax: number;
    readonly effectiveType: "slow-2g" | "2g" | "3g" | "4g";
    readonly rtt: number;
    readonly saveData: boolean;
    readonly type: "bluetooth" | "cellular" | "ethernet" | "none" | "wifi" | "wimax" | "other" | "unknown";
    onChange: (event: Event) => void;
}
interface IUseNetworkState {
    /**
     * @desc Whether browser connected to the network or not.
     */
    online: boolean | undefined;
    /**
     * @desc Previous value of `online` property. Helps to identify if browser
     * just connected or lost connection.
     */
    previous: boolean | undefined;
    /**
     * @desc The {Date} object pointing to the moment when state change occurred.
     */
    since: Date | undefined;
    /**
     * @desc Effective bandwidth estimate in megabits per second, rounded to the
     * nearest multiple of 25 kilobits per seconds.
     */
    downlink: INetworkInformation["downlink"] | undefined;
    /**
     * @desc Maximum downlink speed, in megabits per second (Mbps), for the
     * underlying connection technology
     */
    downlinkMax: INetworkInformation["downlinkMax"] | undefined;
    /**
     * @desc Effective type of the connection meaning one of 'slow-2g', '2g', '3g', or '4g'.
     * This value is determined using a combination of recently observed round-trip time
     * and downlink values.
     */
    effectiveType: INetworkInformation["effectiveType"] | undefined;
    /**
     * @desc Estimated effective round-trip time of the current connection, rounded
     * to the nearest multiple of 25 milliseconds
     */
    rtt: INetworkInformation["rtt"] | undefined;
    /**
     * @desc {true} if the user has set a reduced data usage option on the user agent.
     */
    saveData: INetworkInformation["saveData"] | undefined;
    /**
     * @desc The type of connection a device is using to communicate with the network.
     * It will be one of the following values:
     *  - bluetooth
     *  - cellular
     *  - ethernet
     *  - none
     *  - wifi
     *  - wimax
     *  - other
     *  - unknown
     */
    type: INetworkInformation["type"] | undefined;
}
declare function useNetwork(): IUseNetworkState;

declare function useOnline(): boolean | undefined;

interface OrientationState {
    angle: number;
    type: string;
}
declare function useOrientation(initialState?: OrientationState): readonly [OrientationState, (type: OrientationLockType) => Promise<void> | undefined, () => void];

declare function useIntersectionObserver(target: BasicTarget, callback: IntersectionObserverCallback, options?: IntersectionObserverInit): () => void;

declare function usePageLeave(): boolean;

declare function useDocumentVisibility(defaultValue?: DocumentVisibilityState): DocumentVisibilityState;

declare function useResizeObserver(target: BasicTarget, callback: ResizeObserverCallback, options?: ResizeObserverOptions): () => void;

declare function useDropZone(target: BasicTarget<EventTarget>, onDrop?: (files: File[] | null) => void): boolean;

interface UseFileDialogOptions {
    /**
     * @default true
     */
    multiple?: boolean;
    /**
     * @default '*'
     */
    accept?: string;
    /**
     * Select the input source for the capture file.
     * @see [HTMLInputElement Capture](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/capture)
     */
    capture?: string;
}
declare function useFileDialog(options?: UseFileDialogOptions): readonly [
    FileList | null,
    (localOptions?: Partial<UseFileDialogOptions>) => void,
    () => void
];

interface UseScrollOptions {
    /**
     * Throttle time for scroll event, itâ€™s disabled by default.
     *
     * @default 0
     */
    throttle?: number;
    /**
     * The check time when scrolling ends.
     * This configuration will be setting to (throttle + idle) when the `throttle` is configured.
     *
     * @default 200
     */
    idle?: number;
    /**
     * Offset arrived states by x pixels
     *
     */
    offset?: {
        left?: number;
        right?: number;
        top?: number;
        bottom?: number;
    };
    /**
     * Trigger it when scrolling.
     *
     */
    onScroll?: (e: Event) => void;
    /**
     * Trigger it when scrolling ends.
     *
     */
    onStop?: (e: Event) => void;
    /**
     * Listener options for scroll event.
     *
     * @default {capture: false, passive: true}
     */
    eventListenerOptions?: boolean | AddEventListenerOptions;
}
declare function useScroll(target: BasicTarget<HTMLElement | SVGElement | Window | Document>, options?: UseScrollOptions): readonly [
    number,
    number,
    boolean,
    {
        left: boolean;
        right: boolean;
        top: boolean;
        bottom: boolean;
    },
    {
        left: boolean;
        right: boolean;
        top: boolean;
        bottom: boolean;
    }
];

interface UseInfiniteScrollOptions extends UseScrollOptions {
    /**
     * The minimum distance between the bottom of the element and the bottom of the viewport
     *
     * @default 0
     */
    distance?: number;
    /**
     * The direction in which to listen the scroll.
     *
     * @default 'bottom'
     */
    direction?: "top" | "bottom" | "left" | "right";
    /**
     * Whether to preserve the current scroll position when loading more items.
     *
     * @default false
     */
    preserveScrollPosition?: boolean;
}
declare function useInfiniteScroll(target: BasicTarget<HTMLElement | SVGElement>, onLoadMore: (state: ReturnType<typeof useScroll>) => void | Promise<void>, options?: UseInfiniteScrollOptions): void;

type KeyModifier = "Alt" | "AltGraph" | "CapsLock" | "Control" | "Fn" | "FnLock" | "Meta" | "NumLock" | "ScrollLock" | "Shift" | "Symbol" | "SymbolLock";
interface UseModifierOptions {
    /**
     * Event names that will prompt update to modifier states
     *
     * @default ['mousedown', 'mouseup', 'keydown', 'keyup']
     */
    events?: (keyof WindowEventMap)[];
    /**
     * Initial value of the returned ref
     *
     * @default false
     */
    initial?: boolean;
}
declare function useKeyModifier(modifier: KeyModifier, options?: UseModifierOptions): boolean;

type IHookStateInitialSetter<S> = () => S;
type IHookStateInitAction<S> = S | IHookStateInitialSetter<S>;

interface MousePressedOptions {
    /**
     * Listen to `touchstart` `touchend` events
     *
     * @default true
     */
    touch?: boolean;
    /**
     * Listen to `dragstart` `drop` and `dragend` events
     *
     * @default true
     */
    drag?: boolean;
    /**
     * Initial values
     *
     * @default false
     */
    initialValue?: IHookStateInitAction<boolean>;
}
type MouseSourceType = "mouse" | "touch" | null;
declare function useMousePressed(target?: BasicTarget, options?: MousePressedOptions): readonly [boolean, MouseSourceType];

declare function useScrollLock(target: BasicTarget<HTMLElement>, initialState?: boolean): readonly [boolean, (flag: boolean) => void];

declare function useElementSize(target: BasicTarget, options?: ResizeObserverOptions): readonly [number, number];

interface UseVirtualListOptions {
    /**
     * container default height
     *
     * @default 300
     */
    containerHeight?: number;
    /**
     * item height, accept a pixel value or a function that returns the height
     */
    itemHeight: number | ((index: number) => number);
    /**
     * the extra buffer items outside of the view area
     *
     * @default 5
     */
    overscan?: number;
}
interface UseVirtualListItem<T> {
    data: T;
    index: number;
}
interface UseVirtualListReturn<T> {
    list: UseVirtualListItem<T>[];
    scrollTo: (index: number) => void;
    containerProps: {
        ref: RefObject<any>;
        onScroll: () => void;
        style: Partial<CSSProperties>;
    };
    wrapperProps: {
        style: {
            width: string;
            height: string;
            marginTop: string;
        };
    };
}
declare function useVirtualList<T = any>(list: T[] | undefined, options: UseVirtualListOptions): UseVirtualListReturn<T>;

type ColorScheme = "dark" | "light" | "no-preference";
declare function usePreferredColorScheme(defaultState?: ColorScheme): ColorScheme;

type Contrast = "more" | "less" | "custom" | "no-preference";
declare function usePreferredContrast(defaultState?: Contrast): Contrast;

declare function useActiveElement<T extends Element>(): T | null;

interface UseDraggableOptions {
    /**
     * Only start the dragging when click on the element directly
     *
     * @default false
     */
    exact?: boolean;
    /**
     * Prevent events defaults
     *
     * @default false
     */
    preventDefault?: boolean;
    /**
     * Prevent events propagation
     *
     * @default false
     */
    stopPropagation?: boolean;
    /**
     * Element to attach `pointermove` and `pointerup` events to.
     *
     * @default window
     */
    draggingElement?: BasicTarget<HTMLElement | SVGElement | Window | Document>;
    /**
     * Handle that triggers the drag event
     *
     * @default target
     */
    handle?: BasicTarget<HTMLElement | SVGElement>;
    /**
     * Pointer types that listen to.
     *
     * @default ['mouse', 'touch', 'pen']
     */
    pointerTypes?: PointerType[];
    /**
     * Initial position of the element.
     *
     * @default { x: 0, y: 0 }
     */
    initialValue?: Position;
    /**
     * Callback when the dragging starts. Return `false` to prevent dragging.
     */
    onStart?: (position: Position, event: PointerEvent) => void | false;
    /**
     * Callback during dragging.
     */
    onMove?: (position: Position, event: PointerEvent) => void;
    /**
     * Callback when dragging end.
     */
    onEnd?: (position: Position, event: PointerEvent) => void;
}
declare function useDraggable(target: BasicTarget<HTMLElement | SVGElement>, options?: UseDraggableOptions): readonly [number, number, boolean];

interface UseElementBoundingOptions {
    /**
     * Reset values to 0 on component unmounted
     *
     * @default true
     */
    reset?: boolean;
    /**
     * Listen to window resize event
     *
     * @default true
     */
    windowResize?: boolean;
    /**
     * Listen to window scroll event
     *
     * @default true
     */
    windowScroll?: boolean;
    /**
     * Immediately call update on component mounted
     *
     * @default true
     */
    immediate?: boolean;
}
declare function useElementBounding(target: BasicTarget, options?: UseElementBoundingOptions): {
    readonly height: number;
    readonly bottom: number;
    readonly left: number;
    readonly right: number;
    readonly top: number;
    readonly width: number;
    readonly x: number;
    readonly y: number;
    readonly update: () => void;
};

declare function useElementVisibility(target: BasicTarget<HTMLElement | SVGElement>, options?: IntersectionObserverInit): readonly [boolean, () => void];

declare function useWindowsFocus(defauleValue?: boolean): boolean;

interface WindowSize {
    width: number;
    height: number;
}
declare function useWindowSize(): WindowSize;

interface UseWindowScrollState {
    x: number;
    y: number;
}
declare function useWindowScroll(): UseWindowScrollState;

declare function useClipBorad(): readonly [
    string,
    (txt: string) => Promise<void>
];

type EventType = MouseEvent | TouchEvent;
declare function useClickOutside(target: BasicTarget, handler: (evt: EventType) => void): void;

declare function useCycleList<T>(list: T[], i?: number): readonly [T, (i?: number) => void, (i?: number) => void];

declare function useFocus(target: BasicTarget<HTMLElement | SVGElement>, initialValue?: boolean): readonly [boolean, (value: boolean) => void];

interface IProps<T> {
    controlled?: T;
    defaultValue?: T;
    state?: T;
}
declare function useControlled<T = string>(props?: IProps<T>): readonly [T, (newValue: T) => void];

declare const _default$1: typeof useEffect | typeof react.useLayoutEffect;

declare const _default: typeof react.useEffect | typeof useLayoutEffect;

declare function useReducedMotion(defaultState?: boolean): boolean;

interface ScrollIntoViewAnimation {
    /** target element alignment relatively to parent based on current axis */
    alignment?: "start" | "end" | "center";
}
interface ScrollIntoViewParams {
    /** callback fired after scroll */
    onScrollFinish?: () => void;
    /** duration of scroll in milliseconds */
    duration?: number;
    /** axis of scroll */
    axis?: "x" | "y";
    /** custom mathematical easing function */
    easing?: (t: number) => number;
    /** additional distance between nearest edge and element */
    offset?: number;
    /** indicator if animation may be interrupted by user scrolling */
    cancelable?: boolean;
    /** prevents content jumping in scrolling lists with multiple targets */
    isList?: boolean;
}
declare function useScrollIntoView(targetElement: BasicTarget<HTMLElement>, { duration, axis, onScrollFinish, easing, offset, cancelable, isList, }?: ScrollIntoViewParams, scrollElement?: BasicTarget<HTMLElement>): {
    scrollIntoView: ({ alignment, }?: ScrollIntoViewAnimation) => void;
    cancel: () => void;
};

interface UseStickyParams {
    /** axis of scroll */
    axis?: "x" | "y";
    /** cover height or width */
    nav: number;
}
declare const useSticky: (targetElement: BasicTarget<HTMLElement>, { axis, nav }: UseStickyParams, scrollElement?: BasicTarget<HTMLElement>) => [boolean, react__default.Dispatch<react__default.SetStateAction<boolean>>];

declare function useAsyncEffect<T extends void>(effect: () => Promise<T> | T, cleanup?: typeof effect, deps?: DependencyList): void;

declare const getHMSTime: (timeDiff: number) => [string, string, string];
declare const useCountDown: (time: number, format?: (num: number) => [string, string, string], callback?: () => void) => readonly [string, string, string];

declare function useSupported(callback: () => unknown, sync?: boolean): boolean;

declare function useTextSelection(): Selection | null;

interface EyeDropperOpenOptions {
    signal?: AbortSignal;
}
interface EyeDropperOpenReturnType {
    sRGBHex: string;
}
declare function useEyeDropper(): readonly [boolean, (options?: EyeDropperOpenOptions) => Promise<EyeDropperOpenReturnType>];
type UseEyeDropperReturn = ReturnType<typeof useEyeDropper>;

type UseCookieState = string | undefined;
declare function useCookie(key: string, options?: Cookies.CookieAttributes, defaultValue?: string): readonly [UseCookieState, (newValue: UseCookieState | ((prevState: UseCookieState) => UseCookieState)) => void, () => void];

declare function useDoubleClick({ target, latency, onSingleClick, onDoubleClick, }: {
    target: BasicTarget;
    latency?: number;
    onSingleClick?: (e?: MouseEvent | TouchEvent) => void;
    onDoubleClick?: (e?: MouseEvent | TouchEvent) => void;
}): void;

declare function useSetState<T extends Record<string, any>>(initialState: T): readonly [T, (statePartial: Partial<T> | ((currentState: T) => Partial<T>)) => void];

type UseMeasureRect = Omit<DOMRectReadOnly, "toJSON">;
declare function useMeasure(target: BasicTarget, options?: ResizeObserverOptions): readonly [UseMeasureRect, () => void];

declare function useHover<T extends HTMLElement = HTMLDivElement>(target: BasicTarget<T>): boolean;

declare function useScreenSafeArea(): readonly [string, string, string, string, lodash.DebouncedFunc<() => void>];

interface UseCssVarOptions {
    /**
     * Use MutationObserver to monitor variable changes
     * @default false
     */
    observe?: boolean;
}
declare function useCssVar<T extends HTMLElement = HTMLElement>(prop: string, target: BasicTarget<T>, defaultValue?: string, options?: UseCssVarOptions): readonly [string, (v: string) => void];

declare function useWebNotification(requestPermissions?: boolean): {
    readonly isSupported: boolean;
    readonly show: (title: string, options?: NotificationOptions) => Notification | undefined;
    readonly close: () => void;
    readonly ensurePermissions: () => Promise<boolean | undefined>;
    readonly permissionGranted: react.MutableRefObject<boolean>;
};

declare function useLocationSelector<R>(selector: (location: Location) => R, 
/**
 * @description server fallback
 * @default undefined
 */
fallback?: R): R | undefined;

export { ColorScheme, Contrast, CursorState, EyeDropperOpenReturnType, GeneralPermissionDescriptor, IDisposable, IEvent, IEventOnce, IListener, INetworkInformation, IState, IUseNetworkState, KeyModifier, MousePressedOptions, MouseSourceType, OrientationState, RafLoopReturns, ScrollIntoViewAnimation, ScrollIntoViewParams, Status, Target, UseCookieState, UseCssVarOptions, UseDarkOptions, UseDraggableOptions, UseElementBoundingOptions, UseEventEmitterReturn, UseEyeDropperReturn, UseFileDialogOptions, UseFpsOptions, UseFullScreenOptions, UseInfiniteScrollOptions, UseLongPressOptions, UseMeasureRect, UseMediaDeviceOptions, UseModifierOptions, UseScriptTagOptions, UseScrollOptions, UseStickyParams, UseTextDirectionOptions, UseTextDirectionValue, UseTimeoutFnOptions, UseVirtualListItem, UseVirtualListOptions, UseVirtualListReturn, UseWindowScrollState, WindowSize, getHMSTime, useActiveElement, useAsyncEffect, useClickOutside, useClipBorad as useClipboard, useControlled, useCookie, useCountDown, useCounter, useCssVar, useCustomCompareEffect, useCycleList, useDarkMode, useDebounce, useDebounceFn, useDeepCompareEffect, useDocumentVisibility, useDoubleClick, useDraggable, useDropZone, useElementBounding, useElementSize, useElementVisibility, useEvent, useEventEmitter, useEventListener, useEyeDropper, useFavicon, useFileDialog, useFirstMountState, useFocus, _default$2 as useFps, useFullscreen, useGeolocation, useHover, useIdle, useInfiniteScroll, useIntersectionObserver, useInterval, useIsomorphicLayoutEffect, useKeyModifier, useLatest, useLocalStorage, useLocationSelector, useLongPress, useMeasure, useMediaDevices, useMediaQuery, useMount, useMountedState, useMouse, useMousePressed, useMutationObserver, useNetwork, useObjectUrl, _default$1 as useOnceEffect, _default as useOnceLayoutEffect, useOnline, useOrientation, usePageLeave, usePermission, usePreferredColorScheme, usePreferredContrast, usePreferredDark, usePrevious, useRafFn, useRafState, useReducedMotion, useResizeObserver, useScreenSafeArea, useScriptTag, useScroll, useScrollIntoView, useScrollLock, useSessionStorage, useSetState, useSticky, useSupported, useTextDirection, useTextSelection, useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useTitle, useToggle, useUnmount, useUpdate, _default$4 as useUpdateEffect, _default$3 as useUpdateLayoutEffect, useVirtualList, useWebNotification, useWindowScroll, useWindowSize, useWindowsFocus };
