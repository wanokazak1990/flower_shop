import {
  require_react
} from "./chunk-ZGRSIX2Q.js";
import {
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/@reactuses/core/dist/index.mjs
var import_react = __toESM(require_react(), 1);
function usePrevious(state) {
  const ref = (0, import_react.useRef)();
  (0, import_react.useEffect)(() => {
    ref.current = state;
  });
  return ref.current;
}
function useLatest(value) {
  const ref = (0, import_react.useRef)(value);
  (0, import_react.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref;
}
function useFirstMountState() {
  const isFirst = (0, import_react.useRef)(true);
  if (isFirst.current) {
    isFirst.current = false;
    return true;
  }
  return isFirst.current;
}
var createUpdateEffect = (hook) => (effect, deps) => {
  const isFirstMount = useFirstMountState();
  hook(() => {
    if (!isFirstMount) {
      return effect();
    }
  }, deps);
};
var useUpdateEffect = createUpdateEffect(import_react.useEffect);
var index$3 = createUpdateEffect(import_react.useLayoutEffect);
var _a;
var isFunction$1 = (val) => typeof val === "function";
var isString = (val) => typeof val === "string";
var isDev = true;
var isBrowser = typeof window !== "undefined";
var isNavigator = typeof navigator !== "undefined";
var noop = () => {
};
var isIOS = isBrowser && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
!import_react.default.useId;
function guessSerializerType(rawInit) {
  return rawInit == null || rawInit === void 0 ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : Array.isArray(rawInit) ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
var useIsomorphicLayoutEffect = isBrowser ? import_react.useLayoutEffect : import_react.useEffect;
function useEvent(fn) {
  if (isDev) {
    if (!isFunction$1(fn)) {
      console.error(
        `useEvent expected parameter is a function, got ${typeof fn}`
      );
    }
  }
  const handlerRef = (0, import_react.useRef)(fn);
  useIsomorphicLayoutEffect(() => {
    handlerRef.current = fn;
  }, [fn]);
  return (0, import_react.useCallback)((...args) => {
    const fn2 = handlerRef.current;
    return fn2(...args);
  }, []);
}
var defaultOptions$1 = {};
var defaultOnError = (e) => {
  console.error(e);
};
var StorageSerializers = {
  boolean: {
    read: (v) => v === "true",
    write: (v) => String(v)
  },
  object: {
    read: (v) => JSON.parse(v),
    write: (v) => JSON.stringify(v)
  },
  number: {
    read: (v) => Number.parseFloat(v),
    write: (v) => String(v)
  },
  any: {
    read: (v) => v,
    write: (v) => String(v)
  },
  string: {
    read: (v) => v,
    write: (v) => String(v)
  },
  map: {
    read: (v) => new Map(JSON.parse(v)),
    write: (v) => JSON.stringify(Array.from(v.entries()))
  },
  set: {
    read: (v) => new Set(JSON.parse(v)),
    write: (v) => JSON.stringify(Array.from(v))
  },
  date: {
    read: (v) => new Date(v),
    write: (v) => v.toISOString()
  }
};
var getInitialState$4 = (key, defaultValue, storage, serializer, onError) => {
  if (defaultValue !== void 0) {
    return defaultValue;
  }
  if (isBrowser) {
    try {
      const raw = storage == null ? void 0 : storage.getItem(key);
      if (raw !== void 0 && raw !== null) {
        return serializer == null ? void 0 : serializer.read(raw);
      }
    } catch (error) {
      onError == null ? void 0 : onError(error);
    }
  }
  if (true) {
    console.warn(
      "`createStorage` When server side rendering, defaultValue should be defined to prevent a hydration mismatches."
    );
  }
  return null;
};
function useStorage(key, defaultValue, getStorage = () => isBrowser ? sessionStorage : void 0, options = defaultOptions$1) {
  let storage;
  const { onError = defaultOnError, csrData } = options;
  try {
    storage = getStorage();
  } catch (err) {
    onError(err);
  }
  const type = guessSerializerType(defaultValue);
  const serializer = (0, import_react.useMemo)(() => {
    var _a2;
    return (_a2 = options.serializer) != null ? _a2 : StorageSerializers[type];
  }, [options.serializer, type]);
  const [state, setState] = (0, import_react.useState)(
    getInitialState$4(key, defaultValue, storage, serializer, onError)
  );
  (0, import_react.useEffect)(() => {
    const data = csrData ? isFunction$1(csrData) ? csrData() : csrData : defaultValue;
    const getStoredValue = () => {
      try {
        const raw = storage == null ? void 0 : storage.getItem(key);
        if (raw !== void 0 && raw !== null) {
          return serializer.read(raw);
        } else {
          storage == null ? void 0 : storage.setItem(key, serializer.write(data));
          return data;
        }
      } catch (e) {
        onError(e);
      }
    };
    setState(getStoredValue());
  }, [key, defaultValue, serializer, storage, onError, csrData]);
  const updateState = useEvent(
    (valOrFunc) => {
      const currentState = isFunction$1(valOrFunc) ? valOrFunc(state) : valOrFunc;
      setState(currentState);
      if (currentState === null) {
        storage == null ? void 0 : storage.removeItem(key);
      } else {
        try {
          storage == null ? void 0 : storage.setItem(key, serializer.write(currentState));
        } catch (e) {
          onError(e);
        }
      }
    }
  );
  return [state, updateState];
}
function useLocalStorage(key, defaultValue, options = defaultOptions$1) {
  return useStorage(
    key,
    defaultValue,
    () => isBrowser ? localStorage : void 0,
    options
  );
}
function useSessionStorage(key, defaultValue, options = defaultOptions$1) {
  return useStorage(
    key,
    defaultValue,
    () => isBrowser ? sessionStorage : void 0,
    options
  );
}
var toggleReducer = (state, nextValue) => typeof nextValue === "boolean" ? nextValue : !state;
function useToggle(initialValue) {
  return (0, import_react.useReducer)(toggleReducer, initialValue);
}
function useInterval(callback, delay, options = defaultOptions$1) {
  const immediate = options.immediate;
  const savedCallback = useLatest(callback);
  (0, import_react.useEffect)(() => {
    if (immediate) {
      savedCallback.current();
    }
    if (delay !== null) {
      const interval = setInterval(() => savedCallback.current(), delay || 0);
      return () => clearInterval(interval);
    }
    return void 0;
  }, [delay, immediate]);
}
function useDarkMode(options) {
  const {
    selector = "html",
    attribute = "class",
    classNameDark = "",
    classNameLight = "",
    storageKey = "reactuses-color-scheme",
    storage = () => isBrowser ? localStorage : void 0,
    defaultValue = false
  } = options;
  const value = () => {
    return window.matchMedia("(prefers-color-scheme: dark)").matches;
  };
  const [dark, setDark] = useStorage(
    storageKey,
    defaultValue,
    storage,
    {
      csrData: value
    }
  );
  (0, import_react.useEffect)(() => {
    const element = window == null ? void 0 : window.document.querySelector(selector);
    if (!element) {
      return;
    }
    if (attribute === "class") {
      dark && classNameDark && element.classList.add(classNameDark);
      !dark && classNameLight && element.classList.add(classNameLight);
    } else {
      dark && classNameDark && element.setAttribute(attribute, classNameDark);
      !dark && classNameLight && element.setAttribute(attribute, classNameLight);
    }
    return () => {
      if (!element) {
        return;
      }
      if (attribute === "class") {
        dark && classNameDark && element.classList.remove(classNameDark);
        !dark && classNameLight && element.classList.remove(classNameLight);
      } else {
        dark && classNameDark && element.removeAttribute(attribute);
        !dark && classNameLight && element.removeAttribute(attribute);
      }
    };
  }, [attribute, classNameDark, classNameLight, dark, selector]);
  return [dark, () => setDark((dark2) => !dark2), setDark];
}
var getInitialState$3 = (query, defaultState2) => {
  if (defaultState2 !== void 0) {
    return defaultState2;
  }
  if (isBrowser) {
    return window.matchMedia(query).matches;
  }
  if (true) {
    console.warn(
      "`useMediaQuery` When server side rendering, defaultState should be defined to prevent a hydration mismatches."
    );
  }
  return false;
};
function useMediaQuery(query, defaultState2) {
  const [state, setState] = (0, import_react.useState)(getInitialState$3(query, defaultState2));
  (0, import_react.useEffect)(() => {
    var _a2;
    let mounted = true;
    const mql = window.matchMedia(query);
    const onChange = () => {
      if (!mounted) {
        return;
      }
      setState(!!mql.matches);
    };
    if ("addEventListener" in mql) {
      mql.addEventListener("change", onChange);
    } else {
      (_a2 = mql.addListener) == null ? void 0 : _a2.call(mql, onChange);
    }
    setState(mql.matches);
    return () => {
      var _a22;
      mounted = false;
      if ("removeEventListener" in mql) {
        mql.removeEventListener("change", onChange);
      } else {
        (_a22 = mql.removeListener) == null ? void 0 : _a22.call(mql, onChange);
      }
    };
  }, [query]);
  return state;
}
function usePreferredDark(defaultState2) {
  return useMediaQuery("(prefers-color-scheme: dark)", defaultState2);
}
function useMount(fn) {
  if (isDev) {
    if (!isFunction$1(fn)) {
      console.error(
        `useMount: parameter \`fn\` expected to be a function, but got "${typeof fn}".`
      );
    }
  }
  (0, import_react.useEffect)(() => {
    fn == null ? void 0 : fn();
  }, []);
}
function useUnmount(fn) {
  if (isDev) {
    if (!isFunction$1(fn)) {
      console.error(
        `useUnmount expected parameter is a function, got ${typeof fn}`
      );
    }
  }
  const fnRef = useLatest(fn);
  (0, import_react.useEffect)(
    () => () => {
      fnRef.current();
    },
    [fnRef]
  );
}
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var Symbol = root.Symbol;
var objectProto$b = Object.prototype;
var hasOwnProperty$8 = objectProto$b.hasOwnProperty;
var nativeObjectToString$1 = objectProto$b.toString;
var symToStringTag$1 = Symbol ? Symbol.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$8.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$a = Object.prototype;
var nativeObjectToString = objectProto$a.toString;
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var symbolTag$1 = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
}
var isArray = Array.isArray;
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var asyncTag = "[object AsyncFunction]";
var funcTag$1 = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root["__core-js_shared__"];
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype;
var objectProto$9 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$7).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative(object, key) {
  var value = getValue$1(object, key);
  return baseIsNative(value) ? value : void 0;
}
var WeakMap = getNative(root, "WeakMap");
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
var objectProto$8 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$8;
  return value === proto;
}
function baseTimes(n, iteratee) {
  var index2 = -1, result = Array(n);
  while (++index2 < n) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$2;
}
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;
var isArguments = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$6.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
function stubFalse() {
  return false;
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var Buffer = moduleExports$1 ? root.Buffer : void 0;
var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var argsTag$1 = "[object Arguments]";
var arrayTag$1 = "[object Array]";
var boolTag$1 = "[object Boolean]";
var dateTag$1 = "[object Date]";
var errorTag$1 = "[object Error]";
var funcTag = "[object Function]";
var mapTag$2 = "[object Map]";
var numberTag$1 = "[object Number]";
var objectTag$2 = "[object Object]";
var regexpTag$1 = "[object RegExp]";
var setTag$2 = "[object Set]";
var stringTag$1 = "[object String]";
var weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]";
var dataViewTag$2 = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal.process;
var nodeUtil = function() {
  try {
    var types = freeModule && freeModule.require && freeModule.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$5.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var nativeKeys = overArg(Object.keys, Object);
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$4.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
var nativeCreate = getNative(Object, "create");
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$3.call(data, key) ? data[key] : void 0;
}
var objectProto$3 = Object.prototype;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== void 0 : hasOwnProperty$2.call(data, key);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root, "Map");
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$1 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function arrayPush(array, values) {
  var index2 = -1, length = values.length, offset = array.length;
  while (++index2 < length) {
    array[offset + index2] = values[index2];
  }
  return array;
}
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function arrayFilter(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$2 = Object.prototype;
var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}
var DataView = getNative(root, "DataView");
var Promise$1 = getNative(root, "Promise");
var Set$1 = getNative(root, "Set");
var mapTag$1 = "[object Map]";
var objectTag$1 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag$1 = "[object Set]";
var weakMapTag = "[object WeakMap]";
var dataViewTag$1 = "[object DataView]";
var dataViewCtorString = toSource(DataView);
var mapCtorString = toSource(Map$1);
var promiseCtorString = toSource(Promise$1);
var setCtorString = toSource(Set$1);
var weakMapCtorString = toSource(WeakMap);
var getTag = baseGetTag;
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$1 || Map$1 && getTag(new Map$1()) != mapTag$1 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$1 || WeakMap && getTag(new WeakMap()) != weakMapTag) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$1;
        case mapCtorString:
          return mapTag$1;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$1;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var getTag$1 = getTag;
var Uint8Array = root.Uint8Array;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values) {
  var index2 = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache2, key) {
  return cache2.has(key);
}
var COMPARE_PARTIAL_FLAG$3 = 1;
var COMPARE_UNORDERED_FLAG$1 = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
function mapToArray(map) {
  var index2 = -1, result = Array(map.size);
  map.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
function setToArray(set) {
  var index2 = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$2 = 1;
var COMPARE_UNORDERED_FLAG = 2;
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var symbolProto = Symbol ? Symbol.prototype : void 0;
var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
      return object == other + "";
    case mapTag:
      var convert = mapToArray;
    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var COMPARE_PARTIAL_FLAG$1 = 1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var COMPARE_PARTIAL_FLAG = 1;
var argsTag = "[object Arguments]";
var arrayTag = "[object Array]";
var objectTag = "[object Object]";
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
var now = function() {
  return root.Date.now();
};
var FUNC_ERROR_TEXT$1 = "Expected a function";
var nativeMax = Math.max;
var nativeMin = Math.min;
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
function isEqual(value, other) {
  return baseIsEqual(value, other);
}
var FUNC_ERROR_TEXT = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
function useThrottleFn(fn, wait, options) {
  if (isDev) {
    if (!isFunction$1(fn)) {
      console.error(
        `useThrottleFn expected parameter is a function, got ${typeof fn}`
      );
    }
  }
  const fnRef = useLatest(fn);
  const throttled = (0, import_react.useMemo)(
    () => throttle(
      (...args) => {
        return fnRef.current(...args);
      },
      wait,
      options
    ),
    [wait, options]
  );
  useUnmount(() => {
    throttled.cancel();
  });
  return {
    run: throttled,
    cancel: throttled.cancel,
    flush: throttled.flush
  };
}
function useThrottle(value, wait, options) {
  const [throttled, setThrottled] = (0, import_react.useState)(value);
  const { run } = useThrottleFn(
    () => {
      setThrottled(value);
    },
    wait,
    options
  );
  (0, import_react.useEffect)(() => {
    run();
  }, [run, value]);
  return throttled;
}
function useDebounceFn(fn, wait, options) {
  if (isDev) {
    if (!isFunction$1(fn)) {
      console.error(
        `useDebounceFn expected parameter is a function, got ${typeof fn}`
      );
    }
  }
  const fnRef = useLatest(fn);
  const debounced = (0, import_react.useMemo)(
    () => debounce(
      (...args) => {
        return fnRef.current(...args);
      },
      wait,
      options
    ),
    [options, wait]
  );
  useUnmount(() => {
    debounced.cancel();
  });
  return {
    run: debounced,
    cancel: debounced.cancel,
    flush: debounced.flush
  };
}
function useDebounce(value, wait, options) {
  const [debounced, setDebounced] = (0, import_react.useState)(value);
  const { run } = useDebounceFn(
    () => {
      setDebounced(value);
    },
    wait,
    options
  );
  (0, import_react.useEffect)(() => {
    run();
  }, [run, value]);
  return debounced;
}
function useRafState(initialState) {
  const frame = (0, import_react.useRef)(0);
  const [state, setState] = (0, import_react.useState)(initialState);
  const setRafState = (0, import_react.useCallback)((value) => {
    cancelAnimationFrame(frame.current);
    frame.current = requestAnimationFrame(() => {
      setState(value);
    });
  }, []);
  useUnmount(() => {
    cancelAnimationFrame(frame.current);
  });
  return [state, setRafState];
}
var updateReducer = (num) => (num + 1) % 1e6;
function useUpdate() {
  const [, update] = (0, import_react.useReducer)(updateReducer, 0);
  return update;
}
function useTimeoutFn(cb, interval, options = defaultOptions$1) {
  const { immediate = true } = options;
  const [pending, setPending] = (0, import_react.useState)(false);
  const savedCallback = useLatest(cb);
  const timer = (0, import_react.useRef)();
  const stop = useEvent(() => {
    setPending(false);
    if (timer.current) {
      clearTimeout(timer.current);
    }
  });
  const start = useEvent((...args) => {
    if (timer) {
      clearTimeout(timer.current);
    }
    timer.current = setTimeout(() => {
      setPending(false);
      savedCallback.current(...args);
    }, interval);
    setPending(true);
  });
  (0, import_react.useEffect)(() => {
    if (immediate) {
      start();
    }
    return stop;
  }, [stop, immediate, interval, start]);
  return [pending, start, stop];
}
function useTimeout(ms = 0, options = {}) {
  const update = useUpdate();
  return useTimeoutFn(update, ms, options);
}
function useMountedState() {
  const mountedRef = (0, import_react.useRef)(false);
  const get = (0, import_react.useCallback)(() => mountedRef.current, []);
  (0, import_react.useEffect)(() => {
    mountedRef.current = true;
    return () => {
      mountedRef.current = false;
    };
  }, []);
  return get;
}
function on(obj, ...args) {
  if (obj && obj.addEventListener) {
    obj.addEventListener(
      ...args
    );
  }
}
function off(obj, ...args) {
  if (obj && obj.removeEventListener) {
    obj.removeEventListener(
      ...args
    );
  }
}
var defaultWindow = isBrowser ? window : void 0;
function getTargetElement(target, defaultElement2) {
  if (!isBrowser) {
    return void 0;
  }
  if (!target) {
    return defaultElement2;
  }
  let targetElement;
  if (isFunction$1(target)) {
    targetElement = target();
  } else if ("current" in target) {
    targetElement = target.current;
  } else {
    targetElement = target;
  }
  return targetElement;
}
function useLatestElement(target, defaultElement2) {
  const [latestElement, setLatestElement] = (0, import_react.useState)(
    getTargetElement(target, defaultElement2)
  );
  (0, import_react.useEffect)(() => {
    setLatestElement(getTargetElement(target, defaultElement2));
  }, [target, defaultElement2]);
  return latestElement;
}
function useEventListener(eventName, handler, element, options = defaultOptions$1) {
  const savedHandler = useLatest(handler);
  const targetElement = useLatestElement(element, defaultWindow);
  (0, import_react.useEffect)(() => {
    if (!(targetElement && targetElement.addEventListener)) {
      return;
    }
    const eventListener = (event) => savedHandler.current(event);
    on(targetElement, eventName, eventListener, options);
    return () => {
      if (!(targetElement && targetElement.removeEventListener)) {
        return;
      }
      off(targetElement, eventName, eventListener);
    };
  }, [eventName, targetElement, options, savedHandler]);
}
function useCounter(initialValue = 0, max = null, min = null) {
  const initFunc = () => {
    let init2 = typeof initialValue === "function" ? initialValue() : initialValue;
    typeof init2 !== "number" && console.error(
      `initialValue has to be a number, got ${typeof initialValue}`
    );
    if (typeof min === "number") {
      init2 = Math.max(init2, min);
    } else if (min !== null) {
      console.error(`min has to be a number, got ${typeof min}`);
    }
    if (typeof max === "number") {
      init2 = Math.min(init2, max);
    } else if (max !== null) {
      console.error(`max has to be a number, got ${typeof max}`);
    }
    return init2;
  };
  const [value, setValue] = (0, import_react.useState)(initFunc);
  const set = useEvent(
    (newState) => {
      setValue((v) => {
        let nextValue = typeof newState === "function" ? newState(v) : newState;
        if (typeof min === "number") {
          nextValue = Math.max(nextValue, min);
        }
        if (typeof max === "number") {
          nextValue = Math.min(nextValue, max);
        }
        return nextValue;
      });
    }
  );
  const inc = (delta = 1) => {
    set((value2) => value2 + delta);
  };
  const dec = (delta = 1) => {
    set((value2) => value2 - delta);
  };
  const reset = () => {
    set(initFunc);
  };
  return [value, set, inc, dec, reset];
}
function useRafFn(callback, initiallyActive = true) {
  const raf = (0, import_react.useRef)(null);
  const rafActivity = (0, import_react.useRef)(false);
  const rafCallback = useLatest(callback);
  const step = (0, import_react.useCallback)(
    (time) => {
      if (rafActivity.current) {
        rafCallback.current(time);
        raf.current = requestAnimationFrame(step);
      }
    },
    [rafCallback]
  );
  const result = (0, import_react.useMemo)(
    () => [
      () => {
        if (rafActivity.current) {
          rafActivity.current = false;
          raf.current && cancelAnimationFrame(raf.current);
        }
      },
      () => {
        if (!rafActivity.current) {
          rafActivity.current = true;
          raf.current = requestAnimationFrame(step);
        }
      },
      () => rafActivity.current
      // isActive
    ],
    [step]
  );
  (0, import_react.useEffect)(() => {
    if (initiallyActive) {
      result[1]();
    }
    return result[0];
  }, [initiallyActive, result]);
  return result;
}
function useEventEmitter() {
  const listeners = (0, import_react.useRef)([]);
  const _disposed = (0, import_react.useRef)(false);
  const _event = (0, import_react.useRef)((listener) => {
    listeners.current.push(listener);
    const disposable = {
      dispose: () => {
        if (!_disposed.current) {
          for (let i = 0; i < listeners.current.length; i++) {
            if (listeners.current[i] === listener) {
              listeners.current.splice(i, 1);
              return;
            }
          }
        }
      }
    };
    return disposable;
  });
  const fire = (arg1, arg2) => {
    const queue = [];
    for (let i = 0; i < listeners.current.length; i++) {
      queue.push(listeners.current[i]);
    }
    for (let i = 0; i < queue.length; i++) {
      queue[i].call(void 0, arg1, arg2);
    }
  };
  const dispose = () => {
    if (listeners.current.length !== 0) {
      listeners.current.length = 0;
    }
    _disposed.current = true;
  };
  return [_event.current, fire, dispose];
}
function useFavicon(href, baseUrl = "", rel = "icon") {
  (0, import_react.useEffect)(() => {
    const url = `${baseUrl}${href}`;
    const element = document.head.querySelectorAll(
      `link[rel*="${rel}"]`
    );
    element.forEach((el) => el.href = url);
    if (element.length === 0) {
      const link = document.createElement("link");
      link.rel = rel;
      link.href = url;
      document.getElementsByTagName("head")[0].appendChild(link);
    }
  }, [baseUrl, href, rel]);
}
function useMutationObserver(callback, target, options = defaultOptions$1) {
  const callbackRef = useLatest(callback);
  const observerRef = (0, import_react.useRef)();
  const element = useLatestElement(target);
  const stop = (0, import_react.useCallback)(() => {
    if (observerRef.current) {
      observerRef.current.disconnect();
    }
  }, []);
  (0, import_react.useEffect)(() => {
    if (!element) {
      return;
    }
    observerRef.current = new MutationObserver(callbackRef.current);
    observerRef.current.observe(element, options);
    return stop;
  }, [options, element]);
  return stop;
}
var isPrimitive$1 = (val) => val !== Object(val);
function useCustomCompareEffect(effect, deps, depsEqual) {
  if (true) {
    if (!Array.isArray(deps) || !deps.length) {
      console.warn(
        "`useCustomCompareEffect` should not be used with no dependencies. Use React.useEffect instead."
      );
    }
    if (deps.every(isPrimitive$1)) {
      console.warn(
        "`useCustomCompareEffect` should not be used with dependencies that are all primitive values. Use React.useEffect instead."
      );
    }
    if (typeof depsEqual !== "function") {
      console.warn(
        "`useCustomCompareEffect` should be used with depsEqual callback for comparing deps list"
      );
    }
  }
  const ref = (0, import_react.useRef)(void 0);
  if (!ref.current || !depsEqual(deps, ref.current)) {
    ref.current = deps;
  }
  (0, import_react.useEffect)(effect, ref.current);
}
var isPrimitive = (val) => val !== Object(val);
function useDeepCompareEffect(effect, deps) {
  if (true) {
    if (!Array.isArray(deps) || !deps.length) {
      console.warn(
        "`useDeepCompareEffect` should not be used with no dependencies. Use React.useEffect instead."
      );
    }
    if (deps.every(isPrimitive)) {
      console.warn(
        "`useDeepCompareEffect` should not be used with dependencies that are all primitive values. Use React.useEffect instead."
      );
    }
  }
  useCustomCompareEffect(effect, deps, isEqual);
}
function useTitle(title) {
  (0, import_react.useEffect)(() => {
    document.title = title;
  }, [title]);
}
function useScriptTag(src, onLoaded = noop, options = defaultOptions$1) {
  const {
    immediate = true,
    manual = false,
    type = "text/javascript",
    async = true,
    crossOrigin,
    referrerPolicy,
    noModule,
    defer,
    attrs = {}
  } = options;
  const scriptTag = (0, import_react.useRef)(null);
  const _promise = (0, import_react.useRef)(null);
  const [status, setStatus] = (0, import_react.useState)(src ? "loading" : "idle");
  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {
    const resolveWithElement = (el2) => {
      scriptTag.current = el2;
      resolve(el2);
      return el2;
    };
    if (!document) {
      resolve(false);
      return;
    }
    if (!src) {
      setStatus("idle");
      resolve(false);
      return;
    }
    let shouldAppend = false;
    let el = document.querySelector(
      `script[src="${src}"]`
    );
    if (!el) {
      el = document.createElement("script");
      el.type = type;
      el.async = async;
      el.src = src;
      if (defer) {
        el.defer = defer;
      }
      if (crossOrigin) {
        el.crossOrigin = crossOrigin;
      }
      if (noModule) {
        el.noModule = noModule;
      }
      if (referrerPolicy) {
        el.referrerPolicy = referrerPolicy;
      }
      Object.entries(attrs).forEach(
        ([name2, value]) => el == null ? void 0 : el.setAttribute(name2, value)
      );
      shouldAppend = true;
    } else if (el.hasAttribute("data-loaded")) {
      setStatus(el.getAttribute("data-status"));
      resolveWithElement(el);
    }
    el.addEventListener("error", (event) => {
      setStatus(event.type === "load" ? "ready" : "error");
      return reject(event);
    });
    el.addEventListener("abort", (event) => {
      setStatus(event.type === "load" ? "ready" : "error");
      return reject(event);
    });
    el.addEventListener("load", (event) => {
      setStatus(event.type === "load" ? "ready" : "error");
      el.setAttribute("data-loaded", "true");
      onLoaded(el);
      resolveWithElement(el);
    });
    if (shouldAppend) {
      el = document.head.appendChild(el);
    }
    if (!waitForScriptLoad) {
      resolveWithElement(el);
    }
  });
  const load = (waitForScriptLoad = true) => {
    if (!_promise.current) {
      _promise.current = loadScript(waitForScriptLoad);
    }
    return _promise.current;
  };
  const unload = () => {
    if (!document) {
      return;
    }
    _promise.current = null;
    if (scriptTag.current) {
      scriptTag.current = null;
    }
    const el = document.querySelector(
      `script[src="${src}"]`
    );
    if (el) {
      document.head.removeChild(el);
    }
  };
  useMount(() => {
    if (immediate && !manual) {
      load();
    }
  });
  useUnmount(() => {
    if (!manual) {
      unload();
    }
  });
  return [scriptTag.current, status, load, unload];
}
function usePermission(permissionDesc) {
  const [state, setState] = (0, import_react.useState)("");
  (0, import_react.useEffect)(() => {
    var _a2;
    const desc = typeof permissionDesc === "string" ? { name: permissionDesc } : permissionDesc;
    let mounted = true;
    let permissionStatus = null;
    const onChange = () => {
      if (!mounted) {
        return;
      }
      setState(() => {
        var _a22;
        return (_a22 = permissionStatus == null ? void 0 : permissionStatus.state) != null ? _a22 : "";
      });
    };
    (_a2 = navigator.permissions) == null ? void 0 : _a2.query(desc).then((status) => {
      permissionStatus = status;
      on(permissionStatus, "change", onChange);
      onChange();
    }).catch(noop);
    return () => {
      permissionStatus && off(permissionStatus, "change", onChange);
      mounted = false;
      permissionStatus = null;
    };
  }, [permissionDesc]);
  return state;
}
var isTouchEvent = (ev) => {
  return "touches" in ev;
};
var preventDefault$1 = (ev) => {
  if (!isTouchEvent(ev)) {
    return;
  }
  if (ev.touches.length < 2 && ev.preventDefault) {
    ev.preventDefault();
  }
};
function useLongPress(callback, { isPreventDefault = true, delay = 300 } = defaultOptions$1) {
  const timeout = (0, import_react.useRef)();
  const target = (0, import_react.useRef)();
  const start = (0, import_react.useCallback)(
    (event) => {
      if (isPreventDefault && event.target) {
        on(event.target, "touchend", preventDefault$1, { passive: false });
        target.current = event.target;
      }
      timeout.current = setTimeout(() => callback(event), delay);
    },
    [callback, delay, isPreventDefault]
  );
  const clear = (0, import_react.useCallback)(() => {
    timeout.current && clearTimeout(timeout.current);
    if (isPreventDefault && target.current) {
      off(target.current, "touchend", preventDefault$1);
    }
  }, [isPreventDefault]);
  return {
    onMouseDown: (e) => start(e),
    onTouchStart: (e) => start(e),
    onMouseUp: clear,
    onMouseLeave: clear,
    onTouchEnd: clear
  };
}
function useObjectUrl(object) {
  const [url, setUrl] = (0, import_react.useState)();
  (0, import_react.useEffect)(() => {
    if (object) {
      setUrl(URL.createObjectURL(object));
    }
    return () => {
      if (url) {
        URL.revokeObjectURL(url);
      }
    };
  }, [object]);
  return url;
}
var defaultEvents$1 = [
  "mousemove",
  "mousedown",
  "resize",
  "keydown",
  "touchstart",
  "wheel"
];
var oneMinute = 6e4;
function useIdle(ms = oneMinute, initialState = false, events = defaultEvents$1) {
  const [state, setState] = (0, import_react.useState)(initialState);
  (0, import_react.useEffect)(() => {
    let mounted = true;
    let timeout;
    let localState = state;
    const set = (newState) => {
      if (mounted) {
        localState = newState;
        setState(newState);
      }
    };
    const onEvent = throttle(() => {
      if (localState) {
        set(false);
      }
      clearTimeout(timeout);
      timeout = setTimeout(() => set(true), ms);
    }, 50);
    const onVisibility = () => {
      if (!document.hidden) {
        onEvent();
      }
    };
    for (let i = 0; i < events.length; i++) {
      on(window, events[i], onEvent);
    }
    on(document, "visibilitychange", onVisibility);
    timeout = setTimeout(() => set(true), ms);
    return () => {
      mounted = false;
      for (let i = 0; i < events.length; i++) {
        off(window, events[i], onEvent);
      }
      off(document, "visibilitychange", onVisibility);
    };
  }, [ms, events]);
  return state;
}
function useSupported(callback, sync = false) {
  const [supported, setSupported] = (0, import_react.useState)(false);
  const effect = sync ? useIsomorphicLayoutEffect : import_react.useEffect;
  effect(() => {
    setSupported(Boolean(callback()));
  }, []);
  return supported;
}
var __async$5 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var defaultConstints = { audio: true, video: true };
function useMediaDevices(options = {}) {
  const { requestPermissions, constraints = defaultConstints } = options;
  const [state, setState] = (0, import_react.useState)({ devices: [] });
  const isSupported = useSupported(
    () => navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices
  );
  const permissionGranted = (0, import_react.useRef)(false);
  const stream = (0, import_react.useRef)(null);
  const onChange = (0, import_react.useCallback)(() => {
    navigator.mediaDevices.enumerateDevices().then((devices) => {
      if (stream.current) {
        stream.current.getTracks().forEach((t) => t.stop());
        stream.current = null;
      }
      setState({
        devices: devices.map(({ deviceId, groupId, kind, label }) => ({
          deviceId,
          groupId,
          kind,
          label
        }))
      });
    }).catch(noop);
  }, []);
  const ensurePermissions = (0, import_react.useCallback)(() => __async$5(this, null, function* () {
    if (!isSupported) {
      return false;
    }
    if (permissionGranted.current) {
      return true;
    }
    let state2;
    try {
      state2 = (yield navigator.permissions.query({
        name: "camera"
      })).state;
    } catch (error) {
      state2 = "prompt";
    }
    if (state2 !== "granted") {
      stream.current = yield navigator.mediaDevices.getUserMedia(constraints);
      onChange();
      permissionGranted.current = true;
    } else {
      permissionGranted.current = false;
    }
    return permissionGranted.current;
  }), [onChange, isSupported, constraints]);
  (0, import_react.useEffect)(() => {
    if (!isSupported) {
      return;
    }
    if (requestPermissions) {
      ensurePermissions();
    }
    on(navigator.mediaDevices, "devicechange", onChange);
    onChange();
    return () => {
      off(navigator.mediaDevices, "devicechange", onChange);
    };
  }, [onChange, isSupported, requestPermissions, ensurePermissions]);
  return [state, ensurePermissions];
}
function useTextDirection(options = defaultOptions$1) {
  const { selector = "html", initialValue = "ltr" } = options;
  const getValue2 = () => {
    var _a2, _b;
    if (isBrowser) {
      return (_b = (_a2 = document == null ? void 0 : document.querySelector(selector)) == null ? void 0 : _a2.getAttribute("dir")) != null ? _b : initialValue;
    } else {
      return initialValue;
    }
  };
  const [value, setValue] = (0, import_react.useState)(getValue2());
  const set = (value2) => {
    var _a2, _b;
    if (!isBrowser) {
      return;
    }
    if (value2 !== null) {
      (_a2 = document.querySelector(selector)) == null ? void 0 : _a2.setAttribute("dir", value2);
    } else {
      (_b = document.querySelector(selector)) == null ? void 0 : _b.removeAttribute("dir");
    }
    setValue(value2);
  };
  return [value, set];
}
var initState = {
  screenX: Number.NaN,
  screenY: Number.NaN,
  clientX: Number.NaN,
  clientY: Number.NaN,
  pageX: Number.NaN,
  pageY: Number.NaN,
  elementX: Number.NaN,
  elementY: Number.NaN,
  elementH: Number.NaN,
  elementW: Number.NaN,
  elementPosX: Number.NaN,
  elementPosY: Number.NaN
};
function useMouse(target) {
  const [state, setState] = useRafState(initState);
  useEventListener(
    "mousemove",
    (event) => {
      const { screenX, screenY, clientX, clientY, pageX, pageY } = event;
      const newState = {
        screenX,
        screenY,
        clientX,
        clientY,
        pageX,
        pageY,
        elementX: Number.NaN,
        elementY: Number.NaN,
        elementH: Number.NaN,
        elementW: Number.NaN,
        elementPosX: Number.NaN,
        elementPosY: Number.NaN
      };
      const targetElement = getTargetElement(target);
      if (targetElement) {
        const { left, top, width, height } = targetElement.getBoundingClientRect();
        newState.elementPosX = left + window.pageXOffset;
        newState.elementPosY = top + window.pageYOffset;
        newState.elementX = pageX - newState.elementPosX;
        newState.elementY = pageY - newState.elementPosY;
        newState.elementW = width;
        newState.elementH = height;
      }
      setState(newState);
    },
    () => document
  );
  return state;
}
function useFps(options = defaultOptions$1) {
  var _a2;
  const [fps, setFps] = (0, import_react.useState)(0);
  const every = (_a2 = options.every) != null ? _a2 : 10;
  const last = (0, import_react.useRef)(performance.now());
  const ticks = (0, import_react.useRef)(0);
  useRafFn(() => {
    ticks.current += 1;
    if (ticks.current >= every) {
      const now2 = performance.now();
      const diff = now2 - last.current;
      setFps(Math.round(1e3 / (diff / ticks.current)));
      last.current = now2;
      ticks.current = 0;
    }
  });
  return fps;
}
var useFpsMock = (options) => 0;
var index$2 = typeof performance === "undefined" ? useFpsMock : useFps;
var initCoord = {
  accuracy: 0,
  latitude: Number.POSITIVE_INFINITY,
  longitude: Number.POSITIVE_INFINITY,
  altitude: null,
  altitudeAccuracy: null,
  heading: null,
  speed: null
};
function useGeolocation(options = defaultOptions$1) {
  const {
    enableHighAccuracy = true,
    maximumAge = 3e4,
    timeout = 27e3
  } = options;
  const [coordinates, setCoordinates] = (0, import_react.useState)(initCoord);
  const [locatedAt, setLocatedAt] = (0, import_react.useState)(null);
  const [error, setError] = (0, import_react.useState)(null);
  const updatePosition = (0, import_react.useCallback)((position) => {
    setCoordinates(position.coords);
    setLocatedAt(position.timestamp);
    setError(null);
  }, []);
  const updateError = (0, import_react.useCallback)((err) => {
    setCoordinates(initCoord);
    setLocatedAt(null);
    setError(err);
  }, []);
  (0, import_react.useEffect)(() => {
    navigator.geolocation.getCurrentPosition(updatePosition, updateError);
    const watchId = navigator.geolocation.watchPosition(
      updatePosition,
      updateError,
      {
        enableHighAccuracy,
        maximumAge,
        timeout
      }
    );
    return () => {
      if (watchId) {
        navigator.geolocation.clearWatch(watchId);
      }
    };
  }, [enableHighAccuracy, maximumAge, timeout, updateError, updatePosition]);
  return {
    coordinates,
    locatedAt,
    error
  };
}
var screenfull$1 = { exports: {} };
(function(module2) {
  (function() {
    var document2 = typeof window !== "undefined" && typeof window.document !== "undefined" ? window.document : {};
    var isCommonjs = module2.exports;
    var fn = function() {
      var val;
      var fnMap = [
        [
          "requestFullscreen",
          "exitFullscreen",
          "fullscreenElement",
          "fullscreenEnabled",
          "fullscreenchange",
          "fullscreenerror"
        ],
        // New WebKit
        [
          "webkitRequestFullscreen",
          "webkitExitFullscreen",
          "webkitFullscreenElement",
          "webkitFullscreenEnabled",
          "webkitfullscreenchange",
          "webkitfullscreenerror"
        ],
        // Old WebKit
        [
          "webkitRequestFullScreen",
          "webkitCancelFullScreen",
          "webkitCurrentFullScreenElement",
          "webkitCancelFullScreen",
          "webkitfullscreenchange",
          "webkitfullscreenerror"
        ],
        [
          "mozRequestFullScreen",
          "mozCancelFullScreen",
          "mozFullScreenElement",
          "mozFullScreenEnabled",
          "mozfullscreenchange",
          "mozfullscreenerror"
        ],
        [
          "msRequestFullscreen",
          "msExitFullscreen",
          "msFullscreenElement",
          "msFullscreenEnabled",
          "MSFullscreenChange",
          "MSFullscreenError"
        ]
      ];
      var i = 0;
      var l = fnMap.length;
      var ret = {};
      for (; i < l; i++) {
        val = fnMap[i];
        if (val && val[1] in document2) {
          for (i = 0; i < val.length; i++) {
            ret[fnMap[0][i]] = val[i];
          }
          return ret;
        }
      }
      return false;
    }();
    var eventNameMap = {
      change: fn.fullscreenchange,
      error: fn.fullscreenerror
    };
    var screenfull2 = {
      request: function(element) {
        return new Promise((function(resolve, reject) {
          var onFullScreenEntered = (function() {
            this.off("change", onFullScreenEntered);
            resolve();
          }).bind(this);
          this.on("change", onFullScreenEntered);
          element = element || document2.documentElement;
          Promise.resolve(element[fn.requestFullscreen]()).catch(reject);
        }).bind(this));
      },
      exit: function() {
        return new Promise((function(resolve, reject) {
          if (!this.isFullscreen) {
            resolve();
            return;
          }
          var onFullScreenExit = (function() {
            this.off("change", onFullScreenExit);
            resolve();
          }).bind(this);
          this.on("change", onFullScreenExit);
          Promise.resolve(document2[fn.exitFullscreen]()).catch(reject);
        }).bind(this));
      },
      toggle: function(element) {
        return this.isFullscreen ? this.exit() : this.request(element);
      },
      onchange: function(callback) {
        this.on("change", callback);
      },
      onerror: function(callback) {
        this.on("error", callback);
      },
      on: function(event, callback) {
        var eventName = eventNameMap[event];
        if (eventName) {
          document2.addEventListener(eventName, callback, false);
        }
      },
      off: function(event, callback) {
        var eventName = eventNameMap[event];
        if (eventName) {
          document2.removeEventListener(eventName, callback, false);
        }
      },
      raw: fn
    };
    if (!fn) {
      if (isCommonjs) {
        module2.exports = { isEnabled: false };
      } else {
        window.screenfull = { isEnabled: false };
      }
      return;
    }
    Object.defineProperties(screenfull2, {
      isFullscreen: {
        get: function() {
          return Boolean(document2[fn.fullscreenElement]);
        }
      },
      element: {
        enumerable: true,
        get: function() {
          return document2[fn.fullscreenElement];
        }
      },
      isEnabled: {
        enumerable: true,
        get: function() {
          return Boolean(document2[fn.fullscreenEnabled]);
        }
      }
    });
    if (isCommonjs) {
      module2.exports = screenfull2;
    } else {
      window.screenfull = screenfull2;
    }
  })();
})(screenfull$1);
var screenfull = screenfull$1.exports;
function useFullscreen(target, options = defaultOptions$1) {
  const { onExit, onEnter } = options;
  const [state, setState] = (0, import_react.useState)(false);
  const onChange = () => {
    if (screenfull.isEnabled) {
      const { isFullscreen } = screenfull;
      if (isFullscreen) {
        onEnter == null ? void 0 : onEnter();
      } else {
        screenfull.off("change", onChange);
        onExit == null ? void 0 : onExit();
      }
      setState(isFullscreen);
    }
  };
  const enterFullscreen = () => {
    const el = getTargetElement(target);
    if (!el) {
      return;
    }
    if (screenfull.isEnabled) {
      try {
        screenfull.request(el);
        screenfull.on("change", onChange);
      } catch (error) {
        console.error(error);
      }
    }
  };
  const exitFullscreen = () => {
    if (screenfull.isEnabled) {
      screenfull.exit();
    }
  };
  const toggleFullscreen = () => {
    if (state) {
      exitFullscreen();
    } else {
      enterFullscreen();
    }
  };
  useUnmount(() => {
    if (screenfull.isEnabled) {
      screenfull.off("change", onChange);
    }
  });
  return [
    state,
    {
      enterFullscreen: useEvent(enterFullscreen),
      exitFullscreen: useEvent(exitFullscreen),
      toggleFullscreen: useEvent(toggleFullscreen),
      isEnabled: screenfull.isEnabled
    }
  ];
}
var nav = isNavigator ? navigator : void 0;
var conn = nav && (nav.connection || nav.mozConnection || nav.webkitConnection);
function getConnectionState(previousState) {
  const online = nav == null ? void 0 : nav.onLine;
  const previousOnline = previousState == null ? void 0 : previousState.online;
  return {
    online,
    previous: previousOnline,
    since: online !== previousOnline ? /* @__PURE__ */ new Date() : previousState == null ? void 0 : previousState.since,
    downlink: conn == null ? void 0 : conn.downlink,
    downlinkMax: conn == null ? void 0 : conn.downlinkMax,
    effectiveType: conn == null ? void 0 : conn.effectiveType,
    rtt: conn == null ? void 0 : conn.rtt,
    saveData: conn == null ? void 0 : conn.saveData,
    type: conn == null ? void 0 : conn.type
  };
}
function useNetwork() {
  const [state, setState] = (0, import_react.useState)(getConnectionState);
  (0, import_react.useEffect)(() => {
    const handleStateChange = () => {
      setState(getConnectionState);
    };
    on(window, "online", handleStateChange, { passive: true });
    on(window, "offline", handleStateChange, { passive: true });
    if (conn) {
      on(conn, "change", handleStateChange, { passive: true });
    }
    return () => {
      off(window, "online", handleStateChange);
      off(window, "offline", handleStateChange);
      if (conn) {
        off(conn, "change", handleStateChange);
      }
    };
  }, []);
  return state;
}
function useOnline() {
  const { online } = useNetwork();
  return online;
}
var defaultState$1 = {
  angle: 0,
  type: "landscape-primary"
};
function useOrientation(initialState = defaultState$1) {
  const [state, setState] = (0, import_react.useState)(initialState);
  (0, import_react.useEffect)(() => {
    const screen = window.screen;
    let mounted = true;
    const onChange = () => {
      if (mounted) {
        const { orientation } = screen;
        if (orientation) {
          const { angle, type } = orientation;
          setState({ angle, type });
        } else if (window.orientation !== void 0) {
          setState({
            angle: typeof window.orientation === "number" ? window.orientation : 0,
            type: ""
          });
        }
      }
    };
    on(window, "orientationchange", onChange);
    onChange();
    return () => {
      mounted = false;
      off(window, "orientationchange", onChange);
    };
  }, []);
  const lockOrientation = (type) => {
    if (isBrowser) {
      return;
    }
    if (!(window && "screen" in window && "orientation" in window.screen)) {
      return Promise.reject(new Error("Not supported"));
    }
    return window.screen.orientation.lock(type);
  };
  const unlockOrientation = () => {
    if (isBrowser) {
      return;
    }
    if (!(window && "screen" in window && "orientation" in window.screen)) {
      return;
    }
    return window.screen.orientation.unlock();
  };
  return [state, lockOrientation, unlockOrientation];
}
function useIntersectionObserver(target, callback, options = defaultOptions$1) {
  const savedCallback = useLatest(callback);
  const observerRef = (0, import_react.useRef)();
  const element = useLatestElement(target);
  const stop = (0, import_react.useCallback)(() => {
    if (observerRef.current) {
      observerRef.current.disconnect();
    }
  }, []);
  (0, import_react.useEffect)(() => {
    if (!element) {
      return;
    }
    observerRef.current = new IntersectionObserver(
      savedCallback.current,
      options
    );
    observerRef.current.observe(element);
    return stop;
  }, [options, element]);
  return stop;
}
function usePageLeave() {
  const [isLeft, setIsLeft] = (0, import_react.useState)(false);
  const handler = (event) => {
    if (!window)
      return;
    event = event || window.event;
    const from = event.relatedTarget || event.toElement;
    setIsLeft(!from);
  };
  useEventListener("mouseout", handler, () => window, { passive: true });
  useEventListener("mouseleave", handler, () => document, { passive: true });
  useEventListener("mouseenter", handler, () => document, { passive: true });
  return isLeft;
}
var getInitialState$2 = (defaultValue) => {
  if (defaultValue !== void 0) {
    return defaultValue;
  }
  if (isBrowser) {
    return document.visibilityState;
  }
  if (true) {
    console.warn(
      "`useDocumentVisibility` When server side rendering, defaultValue should be defined to prevent a hydration mismatches."
    );
  }
  return "visible";
};
function useDocumentVisibility(defaultValue) {
  const [visible, setVisible] = (0, import_react.useState)(
    getInitialState$2(defaultValue)
  );
  useEventListener(
    "visibilitychange",
    () => {
      setVisible(document.visibilityState);
    },
    () => document
  );
  (0, import_react.useEffect)(() => {
    setVisible(document.visibilityState);
  }, []);
  return visible;
}
function useResizeObserver(target, callback, options = defaultOptions$1) {
  const savedCallback = useLatest(callback);
  const observerRef = (0, import_react.useRef)();
  const element = useLatestElement(target);
  const stop = (0, import_react.useCallback)(() => {
    if (observerRef.current) {
      observerRef.current.disconnect();
    }
  }, []);
  (0, import_react.useEffect)(() => {
    if (!element) {
      return;
    }
    observerRef.current = new ResizeObserver(savedCallback.current);
    observerRef.current.observe(element, options);
    return stop;
  }, [options, element]);
  return stop;
}
function useDropZone(target, onDrop) {
  const [over, setOver] = (0, import_react.useState)(false);
  const counter = (0, import_react.useRef)(0);
  useEventListener(
    "dragenter",
    (event) => {
      event.preventDefault();
      counter.current += 1;
      setOver(true);
    },
    target
  );
  useEventListener(
    "dragover",
    (event) => {
      event.preventDefault();
    },
    target
  );
  useEventListener(
    "dragleave",
    (event) => {
      event.preventDefault();
      counter.current -= 1;
      if (counter.current === 0) {
        setOver(false);
      }
    },
    target
  );
  useEventListener(
    "drop",
    (event) => {
      var _a2, _b;
      event.preventDefault();
      counter.current = 0;
      setOver(false);
      const files = Array.from((_b = (_a2 = event.dataTransfer) == null ? void 0 : _a2.files) != null ? _b : []);
      onDrop == null ? void 0 : onDrop(files.length === 0 ? null : files);
    },
    target
  );
  return over;
}
var __defProp$2 = Object.defineProperty;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
var DEFAULT_OPTIONS = {
  multiple: true,
  accept: "*"
};
function useFileDialog(options = defaultOptions$1) {
  const [files, setFiles] = (0, import_react.useState)(null);
  const inputRef = (0, import_react.useRef)();
  const initFn = (0, import_react.useCallback)(() => {
    if (typeof document === "undefined") {
      return void 0;
    }
    const input = document.createElement("input");
    input.type = "file";
    input.onchange = (event) => {
      const result = event.target;
      setFiles(result.files);
    };
    return input;
  }, []);
  inputRef.current = initFn();
  const open = (localOptions) => {
    if (!inputRef.current) {
      return;
    }
    const _options = __spreadValues$2(__spreadValues$2(__spreadValues$2({}, DEFAULT_OPTIONS), options), localOptions);
    inputRef.current.multiple = _options.multiple;
    inputRef.current.accept = _options.accept;
    inputRef.current.capture = _options.capture;
    inputRef.current.click();
  };
  const reset = () => {
    setFiles(null);
    if (inputRef.current) {
      inputRef.current.value = "";
    }
  };
  return [files, open, reset];
}
var ARRIVED_STATE_THRESHOLD_PIXELS = 1;
var defaultListerOptions = {
  capture: false,
  passive: true
};
function useScroll(target, options = defaultOptions$1) {
  const {
    throttle: throttle2 = 0,
    idle = 200,
    onStop = noop,
    onScroll = noop,
    offset = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    },
    eventListenerOptions = defaultListerOptions
  } = options;
  const [x, setX] = (0, import_react.useState)(0);
  const [y, setY] = (0, import_react.useState)(0);
  const [isScrolling, setIsScrolling] = (0, import_react.useState)(false);
  const [arrivedState, setArrivedState] = (0, import_react.useState)({
    left: true,
    right: false,
    top: true,
    bottom: false
  });
  const [directions, setDirections] = (0, import_react.useState)({
    left: false,
    right: false,
    top: false,
    bottom: false
  });
  const { run: onScrollEnd } = useDebounceFn((e) => {
    setIsScrolling(false);
    setDirections({ left: false, right: false, top: false, bottom: false });
    onStop(e);
  }, throttle2 + idle);
  const onScrollHandler = useEvent((e) => {
    const eventTarget = e.target === document ? e.target.documentElement : e.target;
    const scrollLeft = eventTarget.scrollLeft;
    let scrollTop = eventTarget.scrollTop;
    if (e.target === document && !scrollTop)
      scrollTop = document.body.scrollTop;
    setX(scrollLeft);
    setY(scrollTop);
    setDirections({
      left: scrollLeft < x,
      right: scrollLeft > x,
      top: scrollTop < y,
      bottom: scrollTop > y
    });
    setArrivedState({
      left: scrollLeft <= 0 + (offset.left || 0),
      right: scrollLeft + eventTarget.clientWidth >= eventTarget.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS,
      top: scrollTop <= 0 + (offset.top || 0),
      bottom: scrollTop + eventTarget.clientHeight >= eventTarget.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS
    });
    setIsScrolling(true);
    onScrollEnd(e);
    onScroll(e);
  });
  const { run: throttleOnScroll } = useThrottleFn(onScrollHandler, throttle2);
  useEventListener(
    "scroll",
    throttle2 ? throttleOnScroll : onScrollHandler,
    target,
    eventListenerOptions
  );
  return [x, y, isScrolling, arrivedState, directions];
}
var __defProp$1 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async$4 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function useInfiniteScroll(target, onLoadMore, options = defaultOptions$1) {
  var _a2, _b;
  const savedLoadMore = useLatest(onLoadMore);
  const direction = (_a2 = options.direction) != null ? _a2 : "bottom";
  const state = useScroll(target, __spreadProps(__spreadValues$1({}, options), {
    offset: __spreadValues$1({
      [direction]: (_b = options.distance) != null ? _b : 0
    }, options.offset)
  }));
  const element = useLatestElement(target);
  const di = state[3][direction];
  useUpdateEffect(() => {
    const fn = () => __async$4(this, null, function* () {
      var _a22, _b2;
      const previous = {
        height: (_a22 = element == null ? void 0 : element.scrollHeight) != null ? _a22 : 0,
        width: (_b2 = element == null ? void 0 : element.scrollWidth) != null ? _b2 : 0
      };
      yield savedLoadMore.current(state);
      if (options.preserveScrollPosition && element) {
        element.scrollTo({
          top: element.scrollHeight - previous.height,
          left: element.scrollWidth - previous.width
        });
      }
    });
    fn();
  }, [di, options.preserveScrollPosition]);
}
var defaultEvents = [
  "mousedown",
  "mouseup",
  "keydown",
  "keyup"
];
function useKeyModifier(modifier, options = defaultOptions$1) {
  const { events = defaultEvents, initial = false } = options;
  const [state, setState] = (0, import_react.useState)(initial);
  useMount(() => {
    events.forEach((listenEvent) => {
      on(document, listenEvent, (evt) => {
        if (typeof evt.getModifierState === "function") {
          setState(evt.getModifierState(modifier));
        }
      });
    });
    return () => {
      events.forEach((listenerEvent) => {
        off(document, listenerEvent, (evt) => {
          if (typeof evt.getModifierState === "function") {
            setState(evt.getModifierState(modifier));
          }
        });
      });
    };
  });
  return state;
}
var listenerOptions$2 = { passive: true };
function useMousePressed(target, options = defaultOptions$1) {
  const { touch = true, drag = true, initialValue = false } = options;
  const [pressed, setPressed] = (0, import_react.useState)(initialValue);
  const [sourceType, setSourceType] = (0, import_react.useState)(null);
  const element = useLatestElement(target);
  const onPressed = (0, import_react.useCallback)(
    (srcType) => () => {
      setPressed(true);
      setSourceType(srcType);
    },
    []
  );
  const onReleased = (0, import_react.useCallback)(() => {
    setPressed(false);
    setSourceType(null);
  }, []);
  useEventListener("mousedown", onPressed("mouse"), target, listenerOptions$2);
  useEventListener("mouseleave", onReleased, () => window, listenerOptions$2);
  useEventListener("mouseup", onReleased, () => window, listenerOptions$2);
  (0, import_react.useEffect)(() => {
    if (drag) {
      element == null ? void 0 : element.addEventListener(
        "dragstart",
        onPressed("mouse"),
        listenerOptions$2
      );
      element == null ? void 0 : element.addEventListener("drop", onReleased, listenerOptions$2);
      element == null ? void 0 : element.addEventListener("dragend", onReleased, listenerOptions$2);
    }
    if (touch) {
      element == null ? void 0 : element.addEventListener(
        "touchstart",
        onPressed("touch"),
        listenerOptions$2
      );
      element == null ? void 0 : element.addEventListener("touchend", onReleased, listenerOptions$2);
      element == null ? void 0 : element.addEventListener("touchcancel", onReleased, listenerOptions$2);
    }
    return () => {
      if (drag) {
        element == null ? void 0 : element.removeEventListener("dragstart", onPressed("mouse"));
        element == null ? void 0 : element.removeEventListener("drop", onReleased);
        element == null ? void 0 : element.removeEventListener("dragend", onReleased);
      }
      if (touch) {
        element == null ? void 0 : element.removeEventListener("touchstart", onPressed("touch"));
        element == null ? void 0 : element.removeEventListener("touchend", onReleased);
        element == null ? void 0 : element.removeEventListener("touchcancel", onReleased);
      }
    };
  }, [drag, onPressed, onReleased, touch, element]);
  return [pressed, sourceType];
}
function preventDefault(rawEvent) {
  const e = rawEvent || window.event;
  if (e.touches.length > 1) {
    return true;
  }
  if (e.preventDefault) {
    e.preventDefault();
  }
  return false;
}
function useScrollLock(target, initialState = false) {
  const [locked, setLocked] = (0, import_react.useState)(initialState);
  const initialOverflowRef = (0, import_react.useRef)("scroll");
  const element = useLatestElement(target);
  (0, import_react.useEffect)(() => {
    if (element) {
      initialOverflowRef.current = element.style.overflow;
      if (locked) {
        element.style.overflow = "hidden";
      }
    }
  }, [locked, element]);
  const lock = useEvent(() => {
    if (!element || locked) {
      return;
    }
    if (isIOS) {
      element.addEventListener("touchmove", preventDefault, {
        passive: false
      });
    }
    setLocked(true);
  });
  const unlock = useEvent(() => {
    if (!element || !locked) {
      return;
    }
    if (isIOS) {
      element.removeEventListener("touchmove", preventDefault);
    }
    element.style.overflow = initialOverflowRef.current;
    setLocked(false);
  });
  const set = useEvent((flag) => {
    if (flag) {
      lock();
    } else {
      unlock();
    }
  });
  return [locked, set];
}
function useElementSize(target, options = defaultOptions$1) {
  const { box = "content-box" } = options;
  const [width, setWidth] = (0, import_react.useState)(0);
  const [height, setHeight] = (0, import_react.useState)(0);
  useResizeObserver(
    target,
    ([entry]) => {
      const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
      if (boxSize) {
        setWidth(boxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0));
        setHeight(boxSize.reduce((acc, { blockSize }) => acc + blockSize, 0));
      } else {
        setWidth(entry.contentRect.width);
        setHeight(entry.contentRect.height);
      }
    },
    options
  );
  return [width, height];
}
function useVirtualList(list = [], options) {
  const containerRef = (0, import_react.useRef)(null);
  const [width, height] = useElementSize(containerRef);
  const [currentList, setCurrentList] = (0, import_react.useState)([]);
  const { itemHeight, overscan = 5, containerHeight = 300 } = options;
  const state = (0, import_react.useRef)({ start: 0, end: 10 });
  const getViewCapacity = (containerHeight2) => {
    if (typeof itemHeight === "number") {
      return Math.ceil(containerHeight2 / itemHeight);
    }
    const { start = 0 } = state.current;
    let sum = 0;
    let capacity = 0;
    for (let i = start; i < list.length; i++) {
      const height2 = itemHeight(i);
      sum += height2;
      if (sum >= containerHeight2) {
        capacity = i;
        break;
      }
    }
    return capacity - start;
  };
  const getOffset = (scrollTop) => {
    if (typeof itemHeight === "number")
      return Math.floor(scrollTop / itemHeight) + 1;
    let sum = 0;
    let offset = 0;
    for (let i = 0; i < list.length; i++) {
      const height2 = itemHeight(i);
      sum += height2;
      if (sum >= scrollTop) {
        offset = i;
        break;
      }
    }
    return offset + 1;
  };
  const calculateRange = useEvent(() => {
    const element = containerRef.current;
    if (element != null) {
      const offset = getOffset(element.scrollTop);
      const viewCapacity = getViewCapacity(element.clientHeight);
      const from = offset - overscan;
      const to = offset + viewCapacity + overscan;
      state.current = {
        start: from < 0 ? 0 : from,
        end: to > list.length ? list.length : to
      };
      const { start, end } = state.current;
      setCurrentList(
        list.slice(start, end).map((ele, index2) => ({
          data: ele,
          index: index2 + start
        }))
      );
    }
  });
  (0, import_react.useEffect)(() => {
    calculateRange();
  }, [width, height, list]);
  const totalHeight = (0, import_react.useMemo)(() => {
    if (typeof itemHeight === "number") {
      return list.length * itemHeight;
    }
    return list.reduce((sum, _, index2) => sum + itemHeight(index2), 0);
  }, [itemHeight, list]);
  const getDistanceTop = (0, import_react.useCallback)(
    (index2) => {
      if (typeof itemHeight === "number") {
        const height3 = index2 * itemHeight;
        return height3;
      }
      const height2 = list.slice(0, index2).reduce((sum, _, i) => sum + itemHeight(i), 0);
      return height2;
    },
    [itemHeight, list]
  );
  const offsetTop = getDistanceTop(state.current.start);
  const wrapperProps = (0, import_react.useMemo)(() => {
    return {
      style: {
        width: "100%",
        height: `${totalHeight - offsetTop}px`,
        marginTop: `${offsetTop}px`
      }
    };
  }, [totalHeight, offsetTop]);
  const scrollTo = (index2) => {
    if (containerRef.current) {
      containerRef.current.scrollTop = getDistanceTop(index2);
      calculateRange();
    }
  };
  const containerStyle = (0, import_react.useMemo)(() => {
    return { overflowY: "auto", height: containerHeight };
  }, [containerHeight]);
  return {
    list: currentList,
    scrollTo,
    containerProps: {
      ref: containerRef,
      onScroll: () => {
        calculateRange();
      },
      style: containerStyle
    },
    wrapperProps
  };
}
function usePreferredColorScheme(defaultState2) {
  const isLight = useMediaQuery("(prefers-color-scheme: light)", false);
  const isDark = useMediaQuery("(prefers-color-scheme: dark)", false);
  if (!isBrowser && defaultState2) {
    return defaultState2;
  }
  return isDark ? "dark" : isLight ? "light" : "no-preference";
}
function usePreferredContrast(defaultState2) {
  const isMore = useMediaQuery("(prefexrs-contrast: more)", false);
  const isLess = useMediaQuery("(prefers-contrast: less)", false);
  const isCustom = useMediaQuery("(prefers-contrast: custom)", false);
  if (!isBrowser && defaultState2) {
    return defaultState2;
  }
  return isMore ? "more" : isLess ? "less" : isCustom ? "custom" : "no-preference";
}
function useActiveElement() {
  const [active, setActive] = (0, import_react.useState)(null);
  const listener = (0, import_react.useCallback)(() => {
    setActive(window == null ? void 0 : window.document.activeElement);
  }, []);
  useEventListener("blur", listener, () => window, true);
  useEventListener("focus", listener, () => window, true);
  return active;
}
function useDraggable(target, options = {}) {
  var _a2, _b;
  const draggingElement = options.draggingElement;
  const draggingHandle = (_a2 = options.handle) != null ? _a2 : target;
  const [position, setPositon] = (0, import_react.useState)(
    (_b = options.initialValue) != null ? _b : { x: 0, y: 0 }
  );
  (0, import_react.useEffect)(() => {
    var _a22;
    setPositon((_a22 = options.initialValue) != null ? _a22 : { x: 0, y: 0 });
  }, [options.initialValue]);
  const [pressedDelta, setPressedDelta] = (0, import_react.useState)();
  const filterEvent = (e) => {
    if (options.pointerTypes) {
      return options.pointerTypes.includes(e.pointerType);
    }
    return true;
  };
  const handleEvent = (e) => {
    if (options.preventDefault) {
      e.preventDefault();
    }
    if (options.stopPropagation) {
      e.stopPropagation();
    }
  };
  const start = (e) => {
    var _a22;
    const element = getTargetElement(target);
    if (!filterEvent(e) || !element) {
      return;
    }
    if (options.exact && e.target !== element) {
      return;
    }
    const rect = element.getBoundingClientRect();
    const pos = {
      x: e.pageX - rect.left,
      y: e.pageY - rect.top
    };
    if (((_a22 = options.onStart) == null ? void 0 : _a22.call(options, pos, e)) === false) {
      return;
    }
    setPressedDelta(pos);
    handleEvent(e);
  };
  const move = (e) => {
    var _a22;
    if (!filterEvent(e)) {
      return;
    }
    if (!pressedDelta) {
      return;
    }
    setPositon({
      x: e.pageX - pressedDelta.x,
      y: e.pageY - pressedDelta.y
    });
    (_a22 = options.onMove) == null ? void 0 : _a22.call(options, position, e);
    handleEvent(e);
  };
  const end = (e) => {
    var _a22;
    if (!filterEvent(e)) {
      return;
    }
    if (!pressedDelta) {
      return;
    }
    setPressedDelta(void 0);
    (_a22 = options.onEnd) == null ? void 0 : _a22.call(options, position, e);
    handleEvent(e);
  };
  useEventListener("pointerdown", start, draggingHandle, true);
  useEventListener("pointermove", move, draggingElement, true);
  useEventListener("pointerup", end, draggingElement, true);
  return [position.x, position.y, !!pressedDelta];
}
function useElementBounding(target, options = defaultOptions$1) {
  const {
    reset = true,
    windowResize = true,
    windowScroll = true,
    immediate = true
  } = options;
  const [height, setHeight] = (0, import_react.useState)(0);
  const [bottom, setBottom] = (0, import_react.useState)(0);
  const [left, setLeft] = (0, import_react.useState)(0);
  const [right, setRight] = (0, import_react.useState)(0);
  const [top, setTop] = (0, import_react.useState)(0);
  const [width, setWidth] = (0, import_react.useState)(0);
  const [x, setX] = (0, import_react.useState)(0);
  const [y, setY] = (0, import_react.useState)(0);
  const update = useEvent(() => {
    const element = getTargetElement(target);
    if (!element) {
      if (reset) {
        setHeight(0);
        setBottom(0);
        setLeft(0);
        setRight(0);
        setTop(0);
        setWidth(0);
        setX(0);
        setY(0);
      }
      return;
    }
    const rect = element.getBoundingClientRect();
    setHeight(rect.height);
    setBottom(rect.bottom);
    setLeft(rect.left);
    setRight(rect.right);
    setTop(rect.top);
    setWidth(rect.width);
    setX(rect.x);
    setY(rect.y);
  });
  useResizeObserver(target, update);
  (0, import_react.useEffect)(() => {
    if (immediate) {
      update();
    }
  }, [immediate, update]);
  (0, import_react.useEffect)(() => {
    if (windowScroll) {
      window.addEventListener("scroll", update, { passive: true });
    }
    if (windowResize) {
      window.addEventListener("resize", update, { passive: true });
    }
    return () => {
      if (windowScroll) {
        window.removeEventListener("scroll", update);
      }
      if (windowResize) {
        window.removeEventListener("resize", update);
      }
    };
  }, [update, windowResize, windowScroll]);
  return {
    height,
    bottom,
    left,
    right,
    top,
    width,
    x,
    y,
    update
  };
}
function useElementVisibility(target, options = defaultOptions$1) {
  const [visible, setVisible] = (0, import_react.useState)(false);
  const callback = (0, import_react.useCallback)((entries) => {
    const rect = entries[0].boundingClientRect;
    setVisible(
      rect.top <= (window.innerHeight || document.documentElement.clientHeight) && rect.left <= (window.innerWidth || document.documentElement.clientWidth) && rect.bottom >= 0 && rect.right >= 0
    );
  }, []);
  const stop = useIntersectionObserver(target, callback, options);
  return [visible, stop];
}
function useWindowsFocus(defauleValue = false) {
  const [focused, setFocused] = (0, import_react.useState)(defauleValue);
  (0, import_react.useEffect)(() => {
    setFocused(window.document.hasFocus());
  }, []);
  useEventListener("blur", () => {
    setFocused(false);
  });
  useEventListener("focus", () => {
    setFocused(true);
  });
  return focused;
}
function useWindowSize() {
  const [windowSize, setWindowSize] = (0, import_react.useState)({
    width: 0,
    height: 0
  });
  const handleSize = () => {
    setWindowSize({
      width: window.innerWidth,
      height: window.innerHeight
    });
  };
  useEventListener("resize", handleSize);
  useIsomorphicLayoutEffect(() => {
    handleSize();
  }, []);
  return windowSize;
}
var listenerOptions$1 = {
  capture: false,
  passive: true
};
function useWindowScroll() {
  const [state, setState] = useRafState(() => ({
    x: 0,
    y: 0
  }));
  const handleScroll = () => {
    setState({ x: window.scrollX, y: window.scrollY });
  };
  useEventListener("scroll", handleScroll, window, listenerOptions$1);
  useIsomorphicLayoutEffect(() => {
    handleScroll();
  }, []);
  return state;
}
var __async$3 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function useClipBorad() {
  const [text, setText] = (0, import_react.useState)("");
  const updateText = (0, import_react.useCallback)(() => {
    window.navigator.clipboard.readText().then((value) => {
      setText(value);
    });
  }, []);
  useEventListener("copy", updateText);
  useEventListener("cut", updateText);
  const copy = (0, import_react.useCallback)((txt) => __async$3(this, null, function* () {
    setText(txt);
    yield window.navigator.clipboard.writeText(txt);
  }), []);
  return [text, copy];
}
var listerOptions = {
  passive: true
};
function useClickOutside(target, handler) {
  const savedHandler = useLatest(handler);
  const listener = (event) => {
    const element = getTargetElement(target);
    if (!element) {
      return;
    }
    const elements = event.composedPath();
    if (element === event.target || elements.includes(element)) {
      return;
    }
    savedHandler.current(event);
  };
  useEventListener("mousedown", listener, defaultWindow, listerOptions);
  useEventListener("touchstart", listener, defaultWindow, listerOptions);
}
function useCycleList(list, i = 0) {
  const [index2, setIndex] = (0, import_react.useState)(i);
  const set = (i2) => {
    const length = list.length;
    const nextIndex = ((index2 + i2) % length + length) % length;
    setIndex(nextIndex);
  };
  const next = (i2 = 1) => {
    set(i2);
  };
  const prev = (i2 = 1) => {
    set(-i2);
  };
  return [list[index2], next, prev];
}
function useFocus(target, initialValue = false) {
  const [focus, innerSetFocus] = (0, import_react.useState)(initialValue);
  useEventListener("focus", () => innerSetFocus(true), target);
  useEventListener("blur", () => innerSetFocus(false), target);
  const setFocus = (value) => {
    const element = getTargetElement(target);
    if (!element) {
      return;
    }
    if (!value) {
      element.blur();
    } else if (value) {
      element.focus();
    }
  };
  useMount(() => {
    setFocus(focus);
  });
  return [focus, setFocus];
}
function useControlled(props) {
  const { controlled, defaultValue: defaultProp, state } = props != null ? props : {
    controlled: void 0,
    defaultValue: void 0,
    state: "value"
  };
  const { current: isControlled } = (0, import_react.useRef)(controlled !== void 0);
  const [valueState, setValue] = (0, import_react.useState)(defaultProp);
  const value = isControlled ? controlled : valueState;
  (0, import_react.useEffect)(() => {
    if (isControlled !== (controlled !== void 0)) {
      console.error(
        [
          `A component is changing the ${isControlled ? "" : "un"}controlled ${state} state of ${name} to be ${isControlled ? "un" : ""}controlled.`,
          "Elements should not switch from uncontrolled to controlled (or vice versa).",
          `Decide between using a controlled or uncontrolled ${name} element for the lifetime of the component.`,
          "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.",
          "More info: https://fb.me/react-controlled-components"
        ].join("\n")
      );
    }
  }, [state, controlled]);
  const setValueIfUncontrolled = (0, import_react.useCallback)((newValue) => {
    if (!isControlled) {
      setValue(newValue);
    }
  }, []);
  return [value, setValueIfUncontrolled];
}
var record = /* @__PURE__ */ new WeakSet();
var createOnceEffect = (hook) => (effect, deps) => {
  const onceWrapper = () => {
    const shouldStart = !record.has(effect);
    if (shouldStart) {
      record.add(effect);
      effect();
    }
  };
  hook(() => {
    onceWrapper();
  }, deps);
};
var index$1 = createOnceEffect(import_react.useEffect);
var index = createOnceEffect(import_react.useLayoutEffect);
function useReducedMotion(defaultState2) {
  return useMediaQuery("(prefers-reduced-motion: reduce)", defaultState2);
}
var setScrollParam = ({
  axis,
  parent,
  distance
}) => {
  if (!parent && typeof document === "undefined") {
    return;
  }
  const method = axis === "y" ? "scrollTop" : "scrollLeft";
  if (parent) {
    parent[method] = distance;
  } else {
    const { body, documentElement } = document;
    body[method] = distance;
    documentElement[method] = distance;
  }
};
var isScrollElement = (axis, node) => {
  if (!node) {
    return false;
  }
  const AXIS = axis === "x" ? "X" : "Y";
  return getComputedStyle(node)[`overflow${AXIS}`] === "auto" || getComputedStyle(node)[`overflow${AXIS}`] === "scroll";
};
var cache = /* @__PURE__ */ new Map();
var getScrollParent = (axis, node) => {
  if (!node || !node.parentElement) {
    return null;
  }
  if (cache.has(node)) {
    return cache.get(node) || null;
  }
  let parent = node.parentElement;
  while (parent && !isScrollElement(axis, parent)) {
    parent = parent.parentElement;
  }
  if (parent) {
    cache.set(node, parent);
  }
  return parent;
};
var getScrollStart = ({
  axis,
  parent
}) => {
  if (!parent && typeof document === "undefined") {
    return 0;
  }
  const method = axis === "y" ? "scrollTop" : "scrollLeft";
  if (parent) {
    return parent[method];
  }
  const { body, documentElement } = document;
  return body[method] + documentElement[method];
};
var easeInOutQuad = (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
var getRelativePosition = ({
  axis,
  target,
  parent,
  alignment,
  offset,
  isList
}) => {
  if (!target || !parent && typeof document === "undefined") {
    return 0;
  }
  const isCustomParent = !!parent;
  const parentElement = parent || document.body;
  const parentPosition = parentElement.getBoundingClientRect();
  const targetPosition = target.getBoundingClientRect();
  const getDiff = (property) => targetPosition[property] - parentPosition[property];
  if (axis === "y") {
    const diff = getDiff("top");
    if (diff === 0) {
      return 0;
    }
    if (alignment === "start") {
      const distance = diff - offset;
      const shouldScroll = distance <= targetPosition.height * (isList ? 0 : 1) || !isList;
      return shouldScroll ? distance : 0;
    }
    const parentHeight = isCustomParent ? parentPosition.height : window.innerHeight;
    if (alignment === "end") {
      const distance = diff + offset - parentHeight + targetPosition.height;
      const shouldScroll = distance >= -targetPosition.height * (isList ? 0 : 1) || !isList;
      return shouldScroll ? distance : 0;
    }
    if (alignment === "center") {
      return diff - parentHeight / 2 + targetPosition.height / 2;
    }
    return 0;
  }
  if (axis === "x") {
    const diff = getDiff("left");
    if (diff === 0) {
      return 0;
    }
    if (alignment === "start") {
      const distance = diff - offset;
      const shouldScroll = distance <= targetPosition.width || !isList;
      return shouldScroll ? distance : 0;
    }
    const parentWidth = isCustomParent ? parentPosition.width : window.innerWidth;
    if (alignment === "end") {
      const distance = diff + offset - parentWidth + targetPosition.width;
      const shouldScroll = distance >= -targetPosition.width || !isList;
      return shouldScroll ? distance : 0;
    }
    if (alignment === "center") {
      return diff - parentWidth / 2 + targetPosition.width / 2;
    }
    return 0;
  }
  return 0;
};
var listenerOptions = { passive: true };
function useScrollIntoView(targetElement, {
  duration = 1250,
  axis = "y",
  onScrollFinish,
  easing = easeInOutQuad,
  offset = 0,
  cancelable = true,
  isList = false
} = defaultOptions$1, scrollElement) {
  const frameID = (0, import_react.useRef)(0);
  const startTime = (0, import_react.useRef)(0);
  const shouldStop = (0, import_react.useRef)(false);
  const reducedMotion = useReducedMotion(false);
  const cancel = () => {
    if (frameID.current) {
      cancelAnimationFrame(frameID.current);
    }
  };
  const element = useLatestElement(targetElement);
  const scrollIntoView = ({
    alignment = "start"
  } = {}) => {
    var _a2;
    const parent = getTargetElement(scrollElement) || getScrollParent(axis, element);
    shouldStop.current = false;
    if (frameID.current) {
      cancel();
    }
    const start = (_a2 = getScrollStart({ parent, axis })) != null ? _a2 : 0;
    const change = getRelativePosition({
      parent,
      target: element,
      axis,
      alignment,
      offset,
      isList
    }) - (parent ? 0 : start);
    const animateScroll = () => {
      if (startTime.current === 0) {
        startTime.current = performance.now();
      }
      const now2 = performance.now();
      const elapsed = now2 - startTime.current;
      const t = reducedMotion || duration === 0 ? 1 : elapsed / duration;
      const distance = start + change * easing(t);
      setScrollParam({
        parent,
        axis,
        distance
      });
      if (!shouldStop.current && t < 1) {
        frameID.current = requestAnimationFrame(animateScroll);
      } else {
        typeof onScrollFinish === "function" && onScrollFinish();
        startTime.current = 0;
        frameID.current = 0;
        cancel();
      }
    };
    animateScroll();
  };
  const handleStop = () => {
    if (cancelable) {
      shouldStop.current = true;
    }
  };
  useEventListener("wheel", handleStop, null, listenerOptions);
  useEventListener("touchmove", handleStop, null, listenerOptions);
  (0, import_react.useEffect)(() => cancel, []);
  return {
    scrollIntoView,
    cancel
  };
}
var useSticky = (targetElement, { axis = "y", nav: nav2 = 0 }, scrollElement) => {
  const [isSticky, setSticky] = (0, import_react.useState)(false);
  const element = useLatestElement(targetElement);
  const { run: scrollHandler } = useThrottleFn(() => {
    if (!element) {
      return;
    }
    const rect = element.getBoundingClientRect();
    if (axis === "y") {
      setSticky((rect == null ? void 0 : rect.top) <= nav2);
    } else {
      setSticky((rect == null ? void 0 : rect.left) <= nav2);
    }
  }, 50);
  (0, import_react.useEffect)(() => {
    const scrollParent = getTargetElement(scrollElement) || getScrollParent(axis, element);
    if (!element || !scrollParent) {
      return;
    }
    scrollParent.addEventListener("scroll", scrollHandler);
    scrollHandler();
    return () => {
      scrollParent.removeEventListener("scroll", scrollHandler);
    };
  }, [axis, element, scrollElement, scrollHandler]);
  return [isSticky, setSticky];
};
var __async$2 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function useAsyncEffect(effect, cleanup = noop, deps) {
  const mounted = useMountedState();
  (0, import_react.useEffect)(() => {
    const execute = () => __async$2(this, null, function* () {
      if (!mounted()) {
        return;
      }
      yield effect();
    });
    execute();
    return () => {
      cleanup();
    };
  }, deps);
}
var padZero = (time) => {
  return `${time}`.length < 2 ? `0${time}` : `${time}`;
};
var getHMSTime = (timeDiff) => {
  if (timeDiff <= 0) {
    return ["00", "00", "00"];
  }
  if (timeDiff > 100 * 3600) {
    return ["99", "59", "59"];
  }
  const hour = Math.floor(timeDiff / 3600);
  const minute = Math.floor((timeDiff - hour * 3600) / 60);
  const second = timeDiff - hour * 3600 - minute * 60;
  return [padZero(hour), padZero(minute), padZero(second)];
};
var useCountDown = (time, format = getHMSTime, callback) => {
  const [remainTime, setRemainTime] = (0, import_react.useState)(time);
  const [delay, setDelay] = (0, import_react.useState)(1e3);
  useInterval(() => {
    if (remainTime <= 0) {
      setDelay(null);
      return;
    }
    setRemainTime(remainTime - 1);
  }, delay);
  (0, import_react.useEffect)(() => {
    if (time > 0 && remainTime <= 0) {
      callback && callback();
    }
  }, [callback, remainTime, time]);
  const [hour, minute, secoud] = format(remainTime);
  return [hour, minute, secoud];
};
function useTextSelection() {
  const [selection, setSelection] = (0, import_react.useState)(null);
  const forceUpdate = useUpdate();
  const handleSelectionChange = () => {
    setSelection(document.getSelection());
    forceUpdate();
  };
  useEventListener("selectionchange", handleSelectionChange, () => document);
  (0, import_react.useEffect)(() => {
    setSelection(document.getSelection());
  }, []);
  return selection;
}
var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function useEyeDropper() {
  const isSupported = useSupported(
    () => typeof window !== "undefined" && "EyeDropper" in window,
    true
  );
  const open = (0, import_react.useCallback)(
    (..._0) => __async$1(this, [..._0], function* (options = {}) {
      if (!isSupported) {
        return {
          sRGBHex: ""
        };
      }
      const eyeDropper = new window.EyeDropper();
      return eyeDropper.open(options);
    }),
    [isSupported]
  );
  return [isSupported, open];
}
function assign(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      target[key] = source[key];
    }
  }
  return target;
}
var defaultConverter = {
  read: function(value) {
    if (value[0] === '"') {
      value = value.slice(1, -1);
    }
    return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
  },
  write: function(value) {
    return encodeURIComponent(value).replace(
      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
      decodeURIComponent
    );
  }
};
function init(converter, defaultAttributes) {
  function set(name2, value, attributes) {
    if (typeof document === "undefined") {
      return;
    }
    attributes = assign({}, defaultAttributes, attributes);
    if (typeof attributes.expires === "number") {
      attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
    }
    if (attributes.expires) {
      attributes.expires = attributes.expires.toUTCString();
    }
    name2 = encodeURIComponent(name2).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
    var stringifiedAttributes = "";
    for (var attributeName in attributes) {
      if (!attributes[attributeName]) {
        continue;
      }
      stringifiedAttributes += "; " + attributeName;
      if (attributes[attributeName] === true) {
        continue;
      }
      stringifiedAttributes += "=" + attributes[attributeName].split(";")[0];
    }
    return document.cookie = name2 + "=" + converter.write(value, name2) + stringifiedAttributes;
  }
  function get(name2) {
    if (typeof document === "undefined" || arguments.length && !name2) {
      return;
    }
    var cookies = document.cookie ? document.cookie.split("; ") : [];
    var jar = {};
    for (var i = 0; i < cookies.length; i++) {
      var parts = cookies[i].split("=");
      var value = parts.slice(1).join("=");
      try {
        var found = decodeURIComponent(parts[0]);
        jar[found] = converter.read(value, found);
        if (name2 === found) {
          break;
        }
      } catch (e) {
      }
    }
    return name2 ? jar[name2] : jar;
  }
  return Object.create(
    {
      set,
      get,
      remove: function(name2, attributes) {
        set(
          name2,
          "",
          assign({}, attributes, {
            expires: -1
          })
        );
      },
      withAttributes: function(attributes) {
        return init(this.converter, assign({}, this.attributes, attributes));
      },
      withConverter: function(converter2) {
        return init(assign({}, this.converter, converter2), this.attributes);
      }
    },
    {
      attributes: { value: Object.freeze(defaultAttributes) },
      converter: { value: Object.freeze(converter) }
    }
  );
}
var api = init(defaultConverter, { path: "/" });
var getInitialState$1 = (key, defaultValue) => {
  if (defaultValue !== void 0) {
    return defaultValue;
  }
  if (isBrowser) {
    return api.get(key);
  }
  if (true) {
    console.warn(
      "`useCookie` When server side rendering, defaultValue should be defined to prevent a hydration mismatches."
    );
  }
  return "";
};
function useCookie(key, options = defaultOptions$1, defaultValue) {
  const [cookieValue, setCookieValue] = (0, import_react.useState)(
    getInitialState$1(key, defaultValue)
  );
  (0, import_react.useEffect)(() => {
    const getStoredValue = () => {
      const raw = api.get(key);
      if (raw !== void 0 && raw !== null) {
        return raw;
      } else {
        if (defaultValue === void 0) {
          api.remove(key);
        } else {
          api.set(key, defaultValue, options);
        }
        return defaultValue;
      }
    };
    setCookieValue(getStoredValue());
  }, [defaultValue, key, options]);
  const updateCookie = (0, import_react.useCallback)(
    (newValue) => {
      const value = isFunction$1(newValue) ? newValue(cookieValue) : newValue;
      if (value === void 0) {
        api.remove(key);
      } else {
        api.set(key, value, options);
      }
      setCookieValue(value);
    },
    [key, cookieValue, options]
  );
  const refreshCookie = (0, import_react.useCallback)(() => {
    const cookieValue2 = api.get(key);
    if (isString(cookieValue2)) {
      setCookieValue(cookieValue2);
    }
  }, [key]);
  return [cookieValue, updateCookie, refreshCookie];
}
function useDoubleClick({
  target,
  latency = 300,
  onSingleClick = () => {
  },
  onDoubleClick = () => {
  }
}) {
  const element = useLatestElement(target);
  const handle = (0, import_react.useCallback)(
    (onSingleClick2, onDoubleClick2) => {
      let count = 0;
      return (e) => {
        if (e.type === "touchend") {
          e.stopPropagation();
          e.preventDefault();
        }
        count += 1;
        setTimeout(() => {
          if (count === 1) {
            onSingleClick2(e);
          } else if (count === 2) {
            onDoubleClick2(e);
          }
          count = 0;
        }, latency);
      };
    },
    [latency]
  );
  const handleClick = handle(onSingleClick, onDoubleClick);
  const handleTouchEnd = handle(onSingleClick, onDoubleClick);
  useEventListener("click", handleClick, element);
  useEventListener("touchend", handleTouchEnd, element, { passive: false });
}
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
function useSetState(initialState) {
  const [state, _setState] = (0, import_react.useState)(initialState);
  const setState = (0, import_react.useCallback)(
    (statePartial) => _setState((current) => __spreadValues(__spreadValues({}, current), typeof statePartial === "function" ? statePartial(current) : statePartial)),
    []
  );
  return [state, setState];
}
var defaultState = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  top: 0,
  left: 0,
  bottom: 0,
  right: 0
};
function useMeasure(target, options = defaultOptions$1) {
  const [rect, setRect] = (0, import_react.useState)(defaultState);
  const stop = useResizeObserver(
    target,
    (entries) => {
      if (entries[0]) {
        const { x, y, width, height, top, left, bottom, right } = entries[0].contentRect;
        setRect({ x, y, width, height, top, left, bottom, right });
      }
    },
    options
  );
  return [rect, stop];
}
function useHover(target) {
  const [hovered, setHovered] = (0, import_react.useState)(false);
  const onMouseEnter = (0, import_react.useCallback)(() => setHovered(true), []);
  const onMouseLeave = (0, import_react.useCallback)(() => setHovered(false), []);
  useEventListener("mouseenter", onMouseEnter, target);
  useEventListener("mouseleave", onMouseLeave, target);
  return hovered;
}
var defaultOptions = {
  observe: false
};
var getInitialState = (defaultValue) => {
  if (defaultValue !== void 0) {
    return defaultValue;
  }
  if (isBrowser) {
    return "";
  }
  if (true) {
    console.warn(
      "`useCssVar` When server side rendering, defaultValue should be defined to prevent a hydration mismatches."
    );
  }
  return "";
};
function useCssVar(prop, target, defaultValue, options = defaultOptions) {
  const { observe } = options;
  const [variable, setVariable] = (0, import_react.useState)(
    getInitialState(defaultValue)
  );
  const element = useLatestElement(target);
  const observerRef = (0, import_react.useRef)();
  const set = (0, import_react.useCallback)(
    (v) => {
      if (element == null ? void 0 : element.style) {
        element == null ? void 0 : element.style.setProperty(prop, v);
        setVariable(v);
      }
    },
    [element, prop]
  );
  const updateCssVar = (0, import_react.useCallback)(() => {
    var _a2;
    if (element) {
      const value = (_a2 = window.getComputedStyle(element).getPropertyValue(prop)) == null ? void 0 : _a2.trim();
      setVariable(value);
    }
  }, [element, prop]);
  (0, import_react.useEffect)(() => {
    var _a2;
    if (!element) {
      return;
    }
    const value = (_a2 = window.getComputedStyle(element).getPropertyValue(prop)) == null ? void 0 : _a2.trim();
    if (!value && defaultValue) {
      set(defaultValue);
    } else {
      updateCssVar();
    }
    if (!observe) {
      return;
    }
    observerRef.current = new MutationObserver(updateCssVar);
    observerRef.current.observe(element, {
      attributeFilter: ["style", "class"]
    });
    return () => {
      if (observerRef.current) {
        observerRef.current.disconnect();
      }
    };
  }, [observe, element, updateCssVar, set, defaultValue, prop]);
  return [variable, set];
}
var topVarName = "--reactuse-safe-area-top";
var rightVarName = "--reactuse-safe-area-right";
var bottomVarName = "--reactuse-safe-area-bottom";
var leftVarName = "--reactuse-safe-area-left";
var defaultElement = () => document.documentElement;
function useScreenSafeArea() {
  const top = (0, import_react.useRef)("");
  const right = (0, import_react.useRef)("");
  const bottom = (0, import_react.useRef)("");
  const left = (0, import_react.useRef)("");
  const forceUpdate = useUpdate();
  useCssVar(topVarName, defaultElement, "env(safe-area-inset-top, 0px)");
  useCssVar(rightVarName, defaultElement, "env(safe-area-inset-right, 0px)");
  useCssVar(bottomVarName, defaultElement, "env(safe-area-inset-bottom, 0px)");
  useCssVar(leftVarName, defaultElement, "env(safe-area-inset-left, 0px)");
  const { run: update } = useDebounceFn(() => {
    top.current = getValue(topVarName);
    right.current = getValue(rightVarName);
    bottom.current = getValue(bottomVarName);
    left.current = getValue(leftVarName);
    forceUpdate();
  });
  (0, import_react.useEffect)(() => {
    update();
  }, [update]);
  useEventListener("resize", update);
  return [
    top.current,
    right.current,
    bottom.current,
    left.current,
    update
  ];
}
function getValue(position) {
  return getComputedStyle(document.documentElement).getPropertyValue(position);
}
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function useWebNotification(requestPermissions = false) {
  const isSupported = useSupported(() => !!window && "Notification" in window);
  const permissionGranted = (0, import_react.useRef)(false);
  const notificationRef = (0, import_react.useRef)(null);
  const show = (title, options = defaultOptions$1) => {
    if (!isSupported && !permissionGranted.current) {
      return;
    }
    notificationRef.current = new Notification(title || "", options);
    return notificationRef.current;
  };
  const close = (0, import_react.useCallback)(() => {
    if (notificationRef.current) {
      notificationRef.current.close();
    }
    notificationRef.current = null;
  }, []);
  (0, import_react.useEffect)(() => {
    permissionGranted.current = isSupported && "permission" in Notification && Notification.permission === "granted";
  }, [isSupported]);
  const ensurePermissions = (0, import_react.useCallback)(() => __async(this, null, function* () {
    if (!isSupported)
      return;
    if (!permissionGranted.current && Notification.permission !== "denied") {
      const result = yield Notification.requestPermission();
      if (result === "granted")
        permissionGranted.current = true;
    }
    return permissionGranted.current;
  }), [isSupported]);
  (0, import_react.useEffect)(() => {
    if (requestPermissions) {
      ensurePermissions();
    }
  }, [requestPermissions, ensurePermissions]);
  useUnmount(close);
  return {
    isSupported,
    show,
    close,
    ensurePermissions,
    permissionGranted
  };
}
function subscribe(callback) {
  window.addEventListener("popstate", callback);
  window.addEventListener("hashchange", callback);
  return () => {
    window.removeEventListener("popstate", callback);
    window.removeEventListener("hashchange", callback);
  };
}
function useLocationSelector(selector, fallback) {
  return (0, import_react.useSyncExternalStore)(
    subscribe,
    () => selector(location),
    () => fallback
  );
}
export {
  getHMSTime,
  useActiveElement,
  useAsyncEffect,
  useClickOutside,
  useClipBorad as useClipboard,
  useControlled,
  useCookie,
  useCountDown,
  useCounter,
  useCssVar,
  useCustomCompareEffect,
  useCycleList,
  useDarkMode,
  useDebounce,
  useDebounceFn,
  useDeepCompareEffect,
  useDocumentVisibility,
  useDoubleClick,
  useDraggable,
  useDropZone,
  useElementBounding,
  useElementSize,
  useElementVisibility,
  useEvent,
  useEventEmitter,
  useEventListener,
  useEyeDropper,
  useFavicon,
  useFileDialog,
  useFirstMountState,
  useFocus,
  index$2 as useFps,
  useFullscreen,
  useGeolocation,
  useHover,
  useIdle,
  useInfiniteScroll,
  useIntersectionObserver,
  useInterval,
  useIsomorphicLayoutEffect,
  useKeyModifier,
  useLatest,
  useLocalStorage,
  useLocationSelector,
  useLongPress,
  useMeasure,
  useMediaDevices,
  useMediaQuery,
  useMount,
  useMountedState,
  useMouse,
  useMousePressed,
  useMutationObserver,
  useNetwork,
  useObjectUrl,
  index$1 as useOnceEffect,
  index as useOnceLayoutEffect,
  useOnline,
  useOrientation,
  usePageLeave,
  usePermission,
  usePreferredColorScheme,
  usePreferredContrast,
  usePreferredDark,
  usePrevious,
  useRafFn,
  useRafState,
  useReducedMotion,
  useResizeObserver,
  useScreenSafeArea,
  useScriptTag,
  useScroll,
  useScrollIntoView,
  useScrollLock,
  useSessionStorage,
  useSetState,
  useSticky,
  useSupported,
  useTextDirection,
  useTextSelection,
  useThrottle,
  useThrottleFn,
  useTimeout,
  useTimeoutFn,
  useTitle,
  useToggle,
  useUnmount,
  useUpdate,
  useUpdateEffect,
  index$3 as useUpdateLayoutEffect,
  useVirtualList,
  useWebNotification,
  useWindowScroll,
  useWindowSize,
  useWindowsFocus
};
/*! Bundled license information:

@reactuses/core/dist/index.mjs:
  (*!
  * screenfull
  * v5.0.0 - 2019-09-09
  * (c) Sindre Sorhus; MIT License
  *)
  (*! js-cookie v3.0.5 | MIT *)
*/
//# sourceMappingURL=@reactuses_core.js.map
